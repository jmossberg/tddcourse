Welcome to this course in Test Driven Development. We will develop a command line tool called <strong>WordsRep</strong> using Test Driven Development methods.

[toc]
<h3>Introduction to Test Driven Development</h3>
Test Driven Development (TDD) is a software development technique where we grow the design by writing unit tests before writing the actual software. We work in an iterative way. This means that we will:
<ol>
	<li>Write a small test</li>
	<li>Make sure it fails</li>
	<li>Make it pass</li>
	<li>Refactor (which means to clean up the code)</li>
</ol>
We can grow the software inside-out (Classic TDD) or outside-in (London TDD):
<ul>
	<li>We start with the core algorithms and work our way out to the public interface of our application when we do <strong>inside-out</strong>(Classic TDD).</li>
	<li>We start with the public interface and work our way in to the core algorithms when we do <strong>outside-in</strong>(London TDD).</li>
</ul>
London TDD will require us to make extensive use of test doubles. Test doubles are stand ins for the real objects. Since the core objects do not yet exist when we start with the public interface we must fake them.

<a href="http://localhost/wordpress/wp-content/uploads/100_InsideOutVsOutsideIn.png"><img class="alignnone size-medium wp-image-21" alt="100_InsideOutVsOutsideIn" src="http://localhost/wordpress/wp-content/uploads/100_InsideOutVsOutsideIn.png" /></a>

We will use inside-out (Classic TDD) when developing the WordsRep application.

The diagram below shows how to design our software to make use of test doubles. The client class depends on an interface expressed using an abstract class. The interface can be implemented by a real class or by a test double. The ClientClass will be satisfied as long as the abstract interface is fulfilled.

<center><a href="http://localhost/wordpress/wp-content/uploads/200_TestDoubles.png"><img class="alignnone size-medium wp-image-21" alt="200_TestDoubles.png" src="http://localhost/wordpress/wp-content/uploads/200_TestDoubles.png" /></a></center>We must design the ClientClass so that we can provide a pointer to either the test double or the real class. We call this dependency injection.

There are different types of test doubles. Gerard Meszaros defines them as follows in his book ''xUnit Test Patterns'':

[table id=1 /]
<h3>Introduction to Google Test</h3>
Google Test can be used to write unit tests. Google Test is written in C++. Google Mock is an addon to Google Test which automates the process of creating mock objects somewhat.

Below is an example of a test written for Google Test/Google Mock.

<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/GoogleTestStructure.png" /></center>We verify that the method <em>getNameLength()</em> returns the correct length of the name that has been stored in the class Person. The test is part of test fixture class <em>PersonTest</em>. A fixture class can be used to initialize objects needed by several tests belonging to the same fixture class.

It is not mandatory to have a fixture class. We could remove it from the example above. But, in that case we must use macro <code>TEST</code> instead of <code>TEST_F</code>:
<pre>TEST(PersonTest, LengthOfNameCanBeRetrieved)</pre>

We use a four phase pattern when writing the test:
<ul>
	<li>Setup phase - prepare all objects needed</li>
	<li>Excercise phase - here we excercise the code we want to verify in this particular test</li>
	<li>Verify phase - we verify the outcome</li>
	<li>Teardown phase - we clean up objects</li>
</ul>
We must also create a ''main.cpp'' that runs the Google Test/Google Mock:
<pre>#include "gmock/gmock.h"

int main(int argc, char* argv[]) {
  ::testing::InitGoogleMock(&amp;argc, argv);
  return RUN_ALL_TESTS();
}</pre>
<h3>The Word Replace tool - WordsRep</h3>
We will develop a command line tool called <strong>WordsRep</strong> in this course. The WordsRep tool searches each line in a text file for a specific word and replaces with another word. The output is written to a new file. Space is the delimiter separating words from one another.

It should accept the following arguments:

[table id=2 /]

<strong>Example 1</strong>
<pre>wordsrep --oldWord car --newWord house --inputFile a.txt --outputFile b.txt</pre>
a.txt
<em>car</em> house street
space blue cow

b.txt
<em>house</em> house street
space blue cow

<strong>Example 2</strong>
<pre>wordsrep --oldWord car --newWord house --inputFile a.txt --outputFile b.txt</pre>
a.txt
<em>car</em> car2 street

b.txt
<em>house</em> car2 street
<h3>The WordsRep reference projects</h3>
A WordsRep reference project is available for each section of this course. Each reference project has its own Eclipse workspace. The reference projects shows the status of the WordsrepApp project after completing the corresponding section. 

The workspaces are available in folder:
<pre>/home/tdd1/workspaces/tddcourse</pre>

Example:
Reference project showing status after completing section 5 is available in workspace:
<pre>/home/tdd1/workspaces/tddcourse/section5</pre>

You can open the corresponding reference project if you get stuck in one of the sections below. Take a look at the reference project to get <em>unstuck</em> and continue with your own workspace again.

<h3>Create a new C++ project in Eclipse CDT and connect to Git repository</h3>
We will create a C++ project in Eclipse CDT to develop our WordsRep application.
<ol>
	<li>Start Eclipse CDT</li>
	<li>Select workspace "/home/tdd1/workspace"</li>
	<li>Close the Welcome screen</li>
	<li>Select "File - New - Other..."</li>
	<li>Select "C/C++ - C++ Project"</li>
	<li>Enter Project Name: ''WordsrepApp''</li>
	<li>Select Project Type ''Makefile project - Empty Project'' and toolchain ''Linux GCC''</li>
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Section5_Eclipse_New_Project.png" /></center>
	<li>Click "Finish"</li>
	<li>Select Yes if asked to open the C/C++ perspective</li>
	<li>Now let's connect the project to a Git repository by right clicking on it and selecting "Team - Share Project...<br>
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Screenshot_team_share_project.png" /></center></li>
	<li>Select Git and click Next</li>
	<li>Click on Create...</li>
	<li>Enter parent directory:
<pre>/home/tdd1/git</pre>
</li>
	<li>Enter name: WordsrepAppGit</li>
	<li>Click Finish</li>
	<li>Click Finish again</li>
</ol>
<h3>Build Google Test and Google Mock in Eclipse using CMake</h3>
Now we will import Google test and Google mock into our Eclipse project and build them with a minimalistic main file.
<ol>
	<li>Right click on the <em>WordsrepApp</em> project in Project Explorer and select New - Folder</li>
	<li>Enter folder name <em>google</em> and click Finish</li>
	<li>Right click on the <em>google</em> folder and select Import...</li>
	<li>Select General - File system and click Next</li>
	<li>Click Browse...</li>
	<li>Select folder /home/tdd1/google and click OK</li>
	<li>Check the google folder and click Finish</li>
        <li>You should now have a gmock-1.7.0 inside the google folder in the Project Explorer</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and choose "Team - Add to Index"</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and choose "Team - Commit"</li>
	<li>Enter message "Add Google Mock" and click "Commit"</li>
	<li>We have now added the Google Mock files to the git repository</li>
	<li>Create a new folder <em>test</em> by right clicking on WordsrepApp and selecting New - Folder</li>
	<li>Right click on the <em>test</em> folder and select New - Source File</li>
	<li>Enter name <em>main.cpp</em> and click on Finish</li>
	<li>Add the following code to <em>main.cpp</em> and save:
<pre>
#include "gmock/gmock.h"

int main(int argc, char* argv[]) {
  ::testing::InitGoogleMock(&amp;argc, argv);
  return RUN_ALL_TESTS();
}
</pre>
</li>
	<li>Right click on the WordsrepApp project and select New - File</li>
	<li>Select WordsrepApp root folder as Parent Directory, enter name "CMakeLists.txt" and click Finish</li>
	<li>Add the following to the <em>CMakeLists.txt</em> and save:
<pre>
#Set minimum CMake version required to run this file
cmake_minimum_required(VERSION 2.8)

#Set name of project 
project("WordsRepAppProj")

#Set compiler flags:
#  std=c+11 <-- Add support for C++11 features
#  g3 <-- Include debugging information in build
#  Wall <-- Enable all compiler warnings messages
add_definitions(-Wall -g3 -std=c++11)

#Add the given directories to those the compiler uses to search for include files
#  CMAKE_CURRENT_SOURCE_DIR <-- This is the directory where the currently processed CMakeLists.txt is located in 
include_directories(${CMAKE_CURRENT_SOURCE_DIR})

#Add a subdirectory to the build. The directory specified must contain a CMakeLists.txt file.
add_subdirectory(test)
</pre>	

</li>
	<li>Create another CMakeLists.txt file inside the test folder</li>
	<li>Add the following to the CMakeLists.txt file inside the test folder
<pre>
#Set a cache and an environment variable
set(GMOCK_DIR "../google/gmock-1.7.0"
    CACHE PATH "The path to the GoogleMock test framework.")

#Add a subdirectory to the build. The directory specified must contain a CMakeLists.txt file.
#  GMOCK_DIR value has been set with the set command
#  CMAKE_BINARY_DIR <-- The path to the top level of the build tree. That is the directory from where cmake is run.
add_subdirectory(${GMOCK_DIR} {CMAKE_BINARY_DIR}/gmock)

#Add the given directories to those the compiler uses to search for include files
include_directories(SYSTEM ${GMOCK_DIR}/gtest/include
                           ${GMOCK_DIR}/include)

include_directories(${CMAKE_SOURCE_DIR}/test)

#The add_executable command tells CMake to create a binary
#The first argument is the name of the binary to create, the
#rest are source files. Header files are not included in this
#command. 
add_executable(wordsrepapptest main.cpp)

#target_link_libraries specifies libraries or flags to use 
#when linking a given target. The named target (first 
#argument) must have been created in the current directory
#with add_executable() or add_library()
target_link_libraries(wordsrepapptest gmock_main)
</pre>
</li>
	<li>Create a new folder <em>build</em> by right clicking on WordsrepApp and selecting New - Folder</li>
	<li>Right click on the build folder and choose "Team - Ignore"</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and choose "Team - Add to Index"</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and choose "Team - Commit"</li>
	<li>Enter message "Import Google Mock and configure build with CMake". Click Commit.</li>
	<li>Now we will create a Make Target to generate the Makefiles from the CMakeLists.txt files.</li>
	<li>Select the <em>Make Target</em> tab on the right side of Eclipse</li>
	<li>Expand the <em>WordsrepApp</em> project and right click on the <em>build</em> folder</li>
	<li>Click on New...</li>
	<li>Enter <em>Target name</em>: cmake</li>
	<li>Uncheck <em>Same as the target name</em></li>
	<li>Enter <em>Build command</em>: cmake ..
	<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Section6_Modify_Make_Target.png" /></center></li>
	<li>Click on OK</li>
	<li>Double-click on the new Make Target cmake. Some files and folders shall be generated in the build folder. You can verify this in the Project Explorer on the left side of Eclipse.</li>
	<li>Now we will configure some WordsrepApp project settings so that we can build</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and select Properties</li> 
	<li>Go to "C/C++ Build", select tab "Builder Settings" and click on Workspace... button</li>
	<li>Expand the folder tree and select the build folder. Click OK</li>
	<li>Click on Apply</li>
	<li>Click on OK to exit the project properties for WordsrepApp</li>
	<li>Select menu Project - Build Project</li>
	<li>Open the Console tab and check that the build went fine</li>
	<li>Select menu Run - Run Configurations...</li>
	<li>Select <em>C/C++ Application</em> on the left and click on the <em>New</em> button</li>
	<li>Enter Name: WordsrepAppConsole</li>
	<li>Click on button <em>Search Project...</em> and select <em>wordsrepapptest</em>. Click OK.</li>
	<li>You should now have <em>build/test/wordsrepapptest</em> in the <em>C/C++ Application</em> field
	<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Section6_Run_Configurations.png" /></center></li>
	<li>Click on Apply and then on Run</li>
	<li>You should get the following in the Console tab:
<pre>
[==========] Running 0 tests from 0 test cases.
[==========] 0 tests from 0 test cases ran. (0 ms total)
[  PASSED  ] 0 tests.
</pre>
This means that we have run all our Google Tests. However currently we have 0 tests in our project.
</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and choose "Team - Add to Index"</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and choose "Team - Commit"</li>
	<li>Enter message "Update Eclipse project settings to build WordsrepApp with CMake". Click Commit.</li>
</ol>

<h3>Add dummy test</h3>
We will add a dummy test to show the basic structure of a test.
<ol>
	<li>Right click on the test folder and select "New - Source File"</li>
	<li>Enter source file name <em>DummyTest.cpp</em> and click "Finish"</li>
	<li>Each test class has to include Google Test and Google Mock.</li>
	<li>Add the following at the top of <em>DummyTest.cpp</em>
<pre>#include "gmock/gmock.h"</pre>
</li>
	<li>Now we add the code for the dummy test.
<pre>TEST(DummyTest, APassingTest) {
  ASSERT_TRUE(true);
}</pre>
</li>
	<li><em>DummyTest.cpp</em> shall now look like this:
<pre>
#include "gmock/gmock.h"

TEST(DummyTest, APassingTest) {
  ASSERT_TRUE(true);
}
</pre>
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/dummy_test.png" /></center></li>
	<li>Save</li>
	<li>Add the new source file to the following line in the CMakeLists.txt file in the test folder:
<pre>
add_executable(wordsrepapptest main.cpp)
</pre>
so that it looks like this
<pre>
add_executable(wordsrepapptest main.cpp DummyTest.cpp)
</pre>
</li>
	<li>Save the CMakeLists.txt file</li>
	<li>Select Project - Build Project</li>
	<li>Click on Run</li>
	<li>The console output shall now show our first test passing:
<pre>
[==========] Running 1 test from 1 test case.
[----------] Global test environment set-up.
[----------] 1 test from DummyTest
[ RUN      ] DummyTest.APassingTest
[       OK ] DummyTest.APassingTest (0 ms)
[----------] 1 test from DummyTest (0 ms total)

[----------] Global test environment tear-down
[==========] 1 test from 1 test case ran. (2 ms total)
[  PASSED  ] 1 test.
</pre>
</li>
	<li>Right click on the project and choose "Team - Add to Index"</li>
	<li>Right click on the project and choose "Team - Commit..."</li>
	<li>Enter message "Add dummy test" and click "Commit"</li>
	<li>You can continue to do git commit like this when you feel appropriate</li>
</ol>
<h3>A test list</h3>
We can compose an initial list of the tests we want to write based on what we know about <strong>WordsRep</strong>.
<ul>
	<li>retrieve the value of an argument switch</li>
	<li>split a line of text into words</li>
	<li>concatenate words into a line of text</li>
	<li>replace all matching words with replacement word</li>
</ul>
We should not spend too much time thinking about this list. The purpose is to get us going.
<h3>Retrieve the value of an argument switch</h3>
WordsRep is a command line tool which means all arguments will be supplied through the main function:
<pre>int main(int argc, char* argv[]) {</pre>
<ul>
	<li><code>argc</code> - argument counter</li>
	<li><code>argv</code> - argument vector</li>
</ul>
<em>argc</em> and <em>argv</em> will assume values according to the table below if we call WordsRep like this:
<pre>wordsrep --oldWord car</pre>
[table id=3 /]

Let's test drive an <em>ArgumentParserClass</em> which will let us parse command line arguments. We write a test to verify that we can retrieve the value of argument switches.
<ol>
	<li>Create a new file, ArgumentParserClassTest.cpp, in the test folder.</li>
	<li>Add the following to the new file:
<pre>
#include "gmock/gmock.h"
#include "ArgumentParserClass.h"

TEST(ArgumentParserClassTest, ValueOfArgumentSwitchCanBeRetrieved) {

  //Setup
  ArgumentParserClass argumentParserClass;

}
</pre>
The test is not finished but we can stop writing here and try to build.
</li>
<li>Add <em>ArgumentParserClassTest.cpp</em> to the following line in test/CMakeLists.txt:
<pre>
add_executable(wordsrepapptest main.cpp DummyTest.cpp)
</pre>
<li>Build project via menu Project - Build Project</li>
<li>The build is failing since we have not implemented ArgumentParserClass. So let's implement an empty ArgumentParserClass.
<li>Add a <em>src</em> folder in the WordsrepApp project by right clicking on the project in the Project Explorer and selecting New - Folder</li>
<li>Create a new file, ArgumentParserClass.h, in the src folder.</li>
<li>The new header file shall contain:
<pre>
#ifndef ARGUMENTPARSERCLASS_H_
#define ARGUMENTPARSERCLASS_H_

class ArgumentParserClass {

};

#endif /* ARGUMENTPARSERCLASS_H_ */
</pre>
</li>
<li>Now we include the <em>src</em> folder when building.</li>
<li>Add the following line in the CMakeLists.txt file in the project root folder:
<pre>
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/src)
</pre>
so that the CMakeLists.txt file looks like this:
<pre>
cmake_minimum_required(VERSION 2.8)

project("WordsRepAppProj")

add_definitions(-Wall -g3 -std=c++11)

include_directories(${CMAKE_CURRENT_SOURCE_DIR})
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/src)

add_subdirectory(test)
</pre>
<li>Build project via menu Project - Build Project</li>
<li>Now the project shall build but with a warning about unused variable</li>
</ol>
You can adjust your coding "speed" based on your experience and the difficulty of the problem at hand. It is not necessary to always halt the writing of a test like this, but I wanted to show that you can go very slowly when you are on unfamiliar territory.

Let's finish the test:
<pre>
TEST(ArgumentParserClassTest, ValueOfArgumentSwitchCanBeRetrieved) {

  //Setup
  int argc { 3 };
  const char * argv1[] = {"wordsrep", "--oldWord", "car"};
  ArgumentParserClass argumentParserClass;

  //Exercise
  auto argumentSwitchValue1 = argumentParserClass.getSwitchValue(argc, argv1, "--oldWord");

  //Verify
  ASSERT_EQ("car", argumentSwitchValue1);
}
</pre>
So what we do here is to setup a scenario where we have 3 arguments (the name of the program, in this case <em>wordsrep</em>, is the first argument). The second argument is a switch, marked with <code>--</code>. We want the <em>getSwitchValue</em> method to return the value after the switch, in this case <em>car</em>.

Build. It should fail because of the missing <em>getSwitchValue</em> method.

Now we implement it.
<ol>
	<li>Edit ArgumentParserClass.h to look like this:
<pre>
#ifndef ARGUMENTPARSERCLASS_H_
#define ARGUMENTPARSERCLASS_H_

#include &lt;string&gt;

class ArgumentParserClass {
public:
  std::string getSwitchValue(const int& argc, const char* argv[], const std::string& switchName);
};

#endif /* ARGUMENTPARSERCLASS_H_ */
</pre>
</li>
	<li>Add a new file ArgumentParserClass.cpp in src folder.</li>
	<li>Add the following:
<pre>
#include "ArgumentParserClass.h"

std::string ArgumentParserClass::getSwitchValue(const int& argc, const char* argv[], const std::string& switchName)
{
  return "car";
}
</pre>
</li>
<li>We have to add a CMakeLists.txt file in the src folder with the following content:
<pre>
#Adds library target called src to be built from the sources files listed
add_library(src ArgumentParserClass.cpp)
</pre>
</li>
<li>We also add the src directory to the end of the CMakeLists.txt file in the project root folder:
<pre>
add_subdirectory(src)
</pre>
</li>
<li>Finally we must make the new src library known to the test application by adding the following line at the end of test/CMakeLists.txt:
<pre>
target_link_libraries(wordsrepapptest src)
</pre>
</li>
</ol>
Build and run test to make sure the test pass:
<pre>
[----------] 1 test from ArgumentParserClassTest
[ RUN      ] ArgumentParserClassTest.ValueOfArgumentSwitchCanBeRetrieved
[       OK ] ArgumentParserClassTest.ValueOfArgumentSwitchCanBeRetrieved (0 ms)
[----------] 1 test from ArgumentParserClassTest (0 ms total)
</pre>
But the response of getSwitchValue is hardcoded. Let's extend the test to force some logic into the implementation:
<pre>
TEST(ArgumentParserClassTest, ValueOfArgumentSwitchCanBeRetrieved) {

  //Setup
  int argc { 3 };
  const char * argv1[] = {"wordsrep", "--oldWord", "car"};
  const char * argv2[] = {"wordsrep", "--oldWord", "space"};
  ArgumentParserClass argumentParserClass;

  //Exercise
  auto argumentSwitchValue1 = argumentParserClass.getSwitchValue(argc, argv1, "--oldWord");
  auto argumentSwitchValue2 = argumentParserClass.getSwitchValue(argc, argv2, "--oldWord");

  //Verify
  ASSERT_EQ("car", argumentSwitchValue1);
  ASSERT_EQ("space", argumentSwitchValue2);
}
</pre>
Make sure the test fails. You should get this in the Console output:
<pre>
[----------] 1 test from ArgumentParserClassTest
[ RUN      ] ArgumentParserClassTest.ValueOfArgumentSwitchCanBeRetrieved
/home/tdd1/git/WordsrepAppGit/WordsrepApp/test/ArgumentParserClassTest.cpp:18: Failure
Value of: argumentSwitchValue2
  Actual: "car"
Expected: "space"
[  FAILED  ] ArgumentParserClassTest.ValueOfArgumentSwitchCanBeRetrieved (0 ms)
[----------] 1 test from ArgumentParserClassTest (0 ms total)
</pre>
So the test expected <em>space</em> to be returned the second time the test called getSwitchValue but got <em>car</em>.
Now we put some logic into ''getSwitchValue'':
<pre>
#include "ArgumentParserClass.h"

std::string ArgumentParserClass::getSwitchValue(const int& argc, const char* argv[], const std::string& switchName)
{
  int i;

  for(i = 0; i &lt; argc; i++)
  {
    if(0 == switchName.compare(argv[i]))
    {
      return argv[i];
    }
  }

  return "";
}
</pre>

Build and run the test.

Hmm, the test still fails with the following output.

<pre>
[----------] 1 test from ArgumentParserClassTest
[ RUN      ] ArgumentParserClassTest.ValueOfArgumentSwitchCanBeRetrieved
/home/tdd1/git/WordsrepAppGit/WordsrepApp/test/ArgumentParserClassTest.cpp:17: Failure
Value of: argumentSwitchValue1
  Actual: "--oldWord"
Expected: "car"
[  FAILED  ] ArgumentParserClassTest.ValueOfArgumentSwitchCanBeRetrieved (0 ms)
[----------] 1 test from ArgumentParserClassTest (3 ms total)
</pre>

The <em>getSwitchValue</em> returned the value <em>--oldWord</em>, but the test expects <em>car</em> to be returned.

Can you spot the error in the code?

The code below has been corrected.

<pre>
#include "ArgumentParserClass.h"

std::string ArgumentParserClass::getSwitchValue(const int& argc, const char* argv[], const std::string& switchName)
{
  int i;

  for(i = 0; i &lt; argc; i++)
  {
    if(0 == switchName.compare(argv[i]))
    {
      return argv[i + 1];
    }
  }

  return "";
}
</pre>

Build and run the test again. Now it should pass.

<h3>Split a line of text into words</h3>
We have implemented the first test on the test list.
<ul>
	<li><span style="text-decoration: line-through;">retrieve the value of an argument switch</span></li>
	<li>split a line of text into words</li>
	<li>concatenate words into line of text</li>
	<li>replace all matching words with replacement word</li>
</ul>
Now we want to test drive how to split a line of text into words. Space is the delimeter used by wordsrep. So everything between two spaces is a word.

We have four words in the following example line:
<pre>car house fire moon_sun</pre>
<ul>
	<li>car</li>
	<li>house</li>
	<li>fire</li>
	<li>moon_sun</li>
</ul>
Let's implement a <em>LineToWordsClass</em> to help us split a line of text into words.

We start with a test.
<ol>
	<li>Add a new file <em>LineToWordsClassTest.cpp</em> in the <em>test</em> folder</li>
	<li>Add the following code:
<pre>
#include "gmock/gmock.h"
#include "LineToWordsClass.h"

TEST(LineToWordsClassTest, CanSplitLineWithTwoWords)
{
  //Setup
  LineToWordsClass lineToWordsClass;
  std::vector&lt;std::string&gt; words;

  //Exercise
  words = lineToWordsClass.splitLine("street sky");

  //Verify
  ASSERT_EQ(2, words.size());
  ASSERT_EQ("street", words[0]);
  ASSERT_EQ("sky", words[1]);
}
</pre>
About the <em>vector</em> type from <em>www.cplusplus.com</em>:
<blockquote style="font-size: medium">Vectors are sequence containers representing arrays that can change in size.

Just like arrays, vectors use contiguous storage locations for their elements, which means that their elements can also be accessed using offsets on regular pointers to its elements, and just as efficiently as in arrays. But unlike arrays, their size can change dynamically, with their storage being handled automatically by the container.</blockquote>
</li>
<li>
Add LineToWordsClassTest to the test/CMakeLists.txt file so that the add_executable command looks like this:
<pre>
add_executable(wordsrepapptest main.cpp DummyTest.cpp ArgumentParserClassTest.cpp LineToWordsClassTest.cpp)
</pre>
</li>
<li>Build. It should fail due to our missing LineToWordsClass implementation.</li>
</ol>
Now let's implement the class <em>LineToWordsClass</em> with method <em>splitLine</em>
<ol>
	<li>Add file LineToWordsClass.h in the <em>src</em> folder</li>
	<li>Add the following code:
<pre>
#ifndef LINETOWORDSCLASS_H_
#define LINETOWORDSCLASS_H_

#include &lt;string&gt;
#include &lt;vector&gt;

class LineToWordsClass {
public:
  std::vector&lt;std::string&gt; splitLine(const std::string& textLine);
};

#endif /* LINETOWORDSCLASS_H_ */
</pre>
</li>
	<li>Add file <em>LineToWordsClass.cpp</em> in the <em>src</em> folder</li>
	<li>Add the following code
<pre>
#include "LineToWordsClass.h"
#include &lt;sstream&gt;

std::vector&lt;std::string&gt; LineToWordsClass::splitLine(
		const std::string& textLine) {

  const int MAX_WORD_LENGTH { 2 };
  char tempbuff[50];
  
  std::vector&lt;std::string&gt; words;
 
  //The stringstream class is good at parsing text. We will use
  //it to split up the line into words.
  std::stringstream ss;
  
  //Copy string to stringstream
  ss << textLine;
  
  //Loop through the ss stringstream looking for space delimiters
  //Extract characters from ss into tempbuff until either
  //the next character equals space or we have reached
  //MAX_WORD_LENGTH number of characters
  //The while loop will finish when there are no more words
  //found by getline
  while(ss.getline(tempbuff, MAX_WORD_LENGTH, ' '))
  {
  	words.push_back(tempbuff);
  }
  
  return words;
}
</pre>
</li>
<li>Add LineToWordsClass.cpp to src/CMakeLists.txt.
<li>Build and run the test.</li>
<li>Hmm, we get the following error:
<pre>
[ RUN      ] LineToWordsClassTest.CanSplitLineWithTwoWords
/home/tdd1/repos/tddcourse/reference/section10/WordsrepApp/test/LineToWordsClassTest.cpp:14: Failure
Value of: words.size()
  Actual: 0
Expected: 2
[  FAILED  ] LineToWordsClassTest.CanSplitLineWithTwoWords (0 ms)
</pre>
The error message does not point us directly to the faulty code. All it says is that the words vector contains 0 words. Can you spot the error in the splitLine method?
<li>We have set MAX_WORD_LENGTH way too low, only 2. Increase it to 20 and try again. Now the test should pass. 
</ol>

<h3>Concatenate words into line of text</h3>
We have implemented two tests on the test list.
<ul>
	<li><span style="text-decoration: line-through;">retrieve the value of an argument switch</span></li>
	<li><span style="text-decoration: line-through;">split a line of text into words</span></li>
	<li>concatenate words into line of text</li>
	<li>replace all matching words with replacement word</li>
</ul>
Now we want to write a test to test drive how to concatenate words into a line of text. We create a new class <em>WordsToLineClass</em>.

We start with a test.

<ol>
<li>Add a new file <em>WordsToLineClassTest.cpp</em> in the <em>test</em> folder
<li>Add the following code:
<pre>
#include "gmock/gmock.h"
#include "WordsToLineClass.h"

TEST(WordsToLineClassTest, ConcatenateThreeWordsIntoLine)
{
  //Setup
  WordsToLineClass wordsToLineClass;

  std::vector&lt;std::string&gt; words;
  words.push_back("table");
  words.push_back("rocket");
  words.push_back("moon");

  std::string line;

  //Exercise
  line = wordsToLineClass.concatenateWords(words);

  //Verify
  ASSERT_EQ("table rocket moon", line);
}
</pre>

The test verifies whether we can concatenate <em>table</em>, <em>rocket</em> and <em>moon</em> into the line:
<pre>
"table rocket moon"
</pre>
<li>Add WordsToLineClassTest.cpp to test/CMakeLists.txt.</li>
<li>Build to make sure it fails because of our missing WordsToLineClass.</li>
</ol>

Now we implement <em>WordsToLineClass</em> and the method <em>concatenateWords</em>.

<ol>
  <li>Add new file <em>WordsToLineClass.h</em> in the <em>src</em> folder and add a definition of class <em>WordsToLineClass</em> with public method:
<pre>
std::string concatenateWords(std::vector&lt;std::string&gt; words);
</pre>
 Remember to include &lt;string&gt; and &lt;vector&gt;.</li>
  <li>Implement the <em>concatenateWords</em> method in the corresponding .cpp class.

<pre>
#include "WordsToLineClass.h"

std::string WordsToLineClass::concatenateWords(std::vector&lt;std::string&gt; words)
{
  std::vector&lt;std::string&gt;::iterator it;
  std::string line("");

  for(it = words.begin(); it != words.end(); it++)
  {
    line.append(*it);
    line.append(" ");
  }

  if(line.size() &gt; 0)
  {
    line.resize(line.size() - 1);
  }

  return line;
}
</pre>

We loop through all words and add them to the line. We also add a space as delimiter between words. We remove the space after the last word before returning.
</li>
<li>Add WordsToLineClass.cpp to src/CMakeLists.txt</li>
<li>Build and run the test to make sure it passes:
<pre>
[----------] 1 test from WordsToLineClassTest
[ RUN      ] WordsToLineClassTest.ConcatenateThreeWordsIntoLine
[       OK ] WordsToLineClassTest.ConcatenateThreeWordsIntoLine (0 ms)
[----------] 1 test from WordsToLineClassTest (0 ms total)
</pre>

We are now free to refactor while under protection from the passing test case. One possible outcome can look like this.

WordsToLineClass.h
<pre>
#ifndef WORDSTOLINECLASS_H_
#define WORDSTOLINECLASS_H_

#include &lt;string&gt;
#include &lt;vector&gt;

class WordsToLineClass {
public:
  std::string concatenateWords(std::vector&lt;std::string&gt;& words);

private:
  std::string addWordToLine(std::string& line, std::string& word);
  std::string removeLastSpaceFromLine(std::string& line);
};

#endif /* WORDSTOLINECLASS_H_ */
</pre>

WordsToLineClass.cpp
<pre>
#include "WordsToLineClass.h"

std::string WordsToLineClass::concatenateWords(std::vector&lt;std::string&gt;& words)
{
  std::string line("");

  for(auto& word: words)
  {
    line = addWordToLine(line, word);
  }

  line = removeLastSpaceFromLine(line);

  return line;
}

std::string WordsToLineClass::addWordToLine(std::string& line, std::string& word) {
  line.append(word);
  line.push_back(' ');
  return line;
}

std::string WordsToLineClass::removeLastSpaceFromLine(std::string& line) {
  if(line.size() &gt; 0)
  {
    line.resize(line.size() - 1);
  }

  return line;
}
</pre>

Do a Project - Clean... in Eclipse after refactoring the code but before building. This is necessary to avoid build error.

<h3>Replace all matching words with replacement word</h3>
We have implemented three tests on the test list.
<ul>
	<li><span style="text-decoration: line-through;">retrieve the value of an argument switch</span></li>
	<li><span style="text-decoration: line-through;">split a line of text into words</span></li>
	<li><span style="text-decoration: line-through;">concatenate words into line of text</span></li>
	<li>replace all matching words with replacement word</li>
</ul>

Now we want to test drive how to replace all words matching an <em>oldWord</em> with a <em>newWord</em>.

<ol>
<li>Add a new file WordsrepClassTest.cpp in the test folder with the following lines:
<pre>
#include "gmock/gmock.h"
#include "WordsrepClass.h"

TEST(WordsrepClassTest, ReplaceMatchingWordsWithNewWord)
{
  //Setup
  WordsrepClass wordsrepClass;

  std::vector&lt;std::string&gt; words;
  words.push_back("table");
  words.push_back("rocket");
  words.push_back("moon");

  std::string oldWord("table");
  std::string newWord("sun");

  std::vector&lt;std::string&gt; newWords;

  //Exercise
  newWords = wordsrepClass.replaceMatchingWords(oldWord, newWord, words);

  //Verify
  ASSERT_EQ("sun",    newWords[0]);
  ASSERT_EQ("rocket", newWords[1]);
  ASSERT_EQ("moon",   newWords[2]);
}
</pre>

The test verifies that method <em>replaceMatchingWords</em> can find the <em>oldWord</em>, replace it with the <em>newWord</em> and the leave the other words as they are.
</li>
<li>Add WordsrepClassTest.cpp to test/CMakeLists.txt.
<li>Build to make sure it fails because of the missing WordsrepClass.</li>
</ol>

Now we implement method <em>replaceMatchingWords</em> in class <em>WordsrepClass</em>.

<ol>
	<li>Add file <em>WordsrepClass.h</em> in <em>src</em> folder with a definition of <em>WordsrepClass</em> including public method:
<pre>
std::vector&lt;std::string&gt; replaceMatchingWords(
  std::string&amp; oldWord, std::string&amp; newWord,
  std::vector&lt;std::string&gt;&amp; words);
</pre>
Remember to include &lt;string&gt; and &lt;vector&gt;.
</li>
	<li>Implement the new method <em>replaceMatchingWords</em> in corresponding .cpp file.</li>

<pre>
#include "WordsrepClass.h"

std::vector&lt;std::string&gt; WordsrepClass::replaceMatchingWords(
std::string&amp; oldWord, std::string&amp; newWord,
std::vector&lt;std::string&gt;&amp; words) {

  std::vector&lt;std::string&gt; newWords;

  for(auto&amp; word: words)
  {
    if(word == oldWord)
    {
      newWords.push_back(newWord);
    }
    else
    {
      newWords.push_back(word);
    }
  }

  return newWords;
}
</pre>
</li>
<li>Add WordsrepClass.cpp to src/CMakeLists.txt.</li>

<li>Build and run test to make sure it passes:
<pre>
[----------] 1 test from WordsrepClassTest
[ RUN      ] WordsrepClassTest.ReplaceMatchingWordsWithNewWord
[       OK ] WordsrepClassTest.ReplaceMatchingWordsWithNewWord (0 ms)
[----------] 1 test from WordsrepClassTest (0 ms total)
</pre>

<h3>Use mock objects to abstract the file system dependency</h3>
Ok, so we have implemented all the tests on our initial test list:
<ul>
	<li><span style="text-decoration: line-through;">retrieve the value of an argument switch</span></li>
	<li><span style="text-decoration: line-through;">split a line of text into words</span></li>
	<li><span style="text-decoration: line-through;">concatenate words into line of text</span></li>
	<li><span style="text-decoration: line-through;">replace all matching words with replacement word</span></li>
</ul>

But we are not done. <strong>WordsrepApp</strong> will have to read and write text lines from and to files. However this dependency towards a file system is typically something we want to abstract in our unit tests. We can do this using mock objects. What we have to do first is to define abstract interfaces through which WordsrepApp can interact with the file system. We will let mock objects implement the abstract interfaces while running our unit tests.

We define one abstract interface, <em>AbstractFileReaderInterface</em>, for reading from files. It stipulates that four methods should be implemented:

<ul>
<li>openFile
<li>closeFile
<li>readLine - returns next line
<li>endOfData - returns true if we have reached end of file
</ul>

We define one abstract interface, <em>AbstractFileWriterInterface</em>, for writing to files. It stipulates that four methods should be implemented:

<ul>
<li>openFile
<li>closeFile
<li>writeLine - inserts a string into the file but does not make a line feed
<li>lineFeed - inserts line feed into file
</ul>

The figure belows shows the abstract interfaces and how they can be implemented by mock ojects or the by the <em>real</em> classes.

<center><a href="http://localhost/wordpress/wp-content/uploads/300_MockObjects.png"><img class="alignnone size-medium wp-image-21" alt="300_MockObjects.png" src="http://localhost/wordpress/wp-content/uploads/300_MockObjects.png" /></a></center>

We use pure virtual methods to implement abstract classes. From Wikipedia:

<blockquote cite="http://en.wikipedia.org/wiki/Virtual_function#Abstract_classes_and_pure_virtual_functions">
A pure virtual function or <strong>pure virtual method</strong> is a virtual function that is required to be implemented by a derived class, if that class is not abstract. Classes containing pure virtual methods are termed "abstract" and they cannot be instantiated directly. A subclass of an abstract class can only be instantiated directly if all inherited pure virtual methods have been implemented by that class or a parent class. Pure virtual methods typically have a declaration (signature) and no definition (implementation).
</blockquote>

We add <strong>= 0</strong> to the method declaration (signature) to make it a pure virtual method.

Now we define the <em>AbstractFileReaderInterface</em> and <em>AbstractFileWriterInterface</em> in Eclipse.

<ul>
	<li>Add a new folder <em>interface</em> in the WordsrepApp project</li>
	<li>Add a new file <em>AbstractFileReaderInterface.h</em> in the <em>interface</em> folder</li>
	<li>Add the following code:
<pre>
#ifndef ABSTRACTFILEREADERINTERFACE_H_
#define ABSTRACTFILEREADERINTERFACE_H_

#include &lt;string&gt;

class AbstractFileReaderInterface {
public:
  virtual ~AbstractFileReaderInterface() {}
  virtual int openFile(const std::string& fileName) = 0;
  virtual int closeFile() = 0;
  virtual std::string readLine() = 0;
  virtual bool endOfData() = 0;
};

#endif /* ABSTRACTFILEREADERINTERFACE_H_ */
</pre>
</li>
	<li>Add a new file <em>AbstractFileWriterInterface.h</em> in the <em>interface</em> folder</li>
	<li>Add the following code:
<pre>
#ifndef ABSTRACTFILEWRITERINTERFACE_H_
#define ABSTRACTFILEWRITERINTERFACE_H_

#include &lt;string&gt;

class AbstractFileWriterInterface {
public:
  virtual ~AbstractFileWriterInterface() {}
  virtual int openFile(const std::string& fileName) = 0;
  virtual int closeFile() = 0;
  virtual void writeLine(const std::string& newLine) = 0;
  virtual void lineFeed() = 0;
  virtual void setEndOfData() = 0;
};

#endif /* ABSTRACTFILEWRITERINTERFACE_H_ */
</pre>
</li>
</ul>

Next step is to create mock objects using Google Mock. We must tell Google Mock what abstract interface to implement. We do this by declaring a mock class that inherits from the abstract interface. We define the methods in the mock class using syntax:

<code>
MOCK_METHODn(<em>&lt;function name></em>, <em>&lt;type of function></em>);
</code>

n is the number of arguments. We write one MOCK_METHOD per pure virtual method in the abstract class. The examples below will make it more clear. You can also have a look at https://code.google.com/p/googlemock/wiki/V1_7_ForDummies#Writing_the_Mock_Class. Or look in <code>/home/tdd1/Documents</code> if you are offline. The Documents folder contains downloaded Google Test and Google Mock documentation.

We start with the <em>FileReaderMock</em>.
<ul>
	<li>Add a new folder <em>mock</em> in the test folder</li>
	<li>Add a new file <em>FileReaderMock.h</em> inside the mock folder</li>
	<li>Add the following code:
<pre>
#ifndef FILEREADERMOCK_H_
#define FILEREADERMOCK_H_

#include "gmock/gmock.h"
#include "AbstractFileReaderInterface.h"

class FileReaderMock : public AbstractFileReaderInterface {
public:
  MOCK_METHOD1(openFile, int(const std::string& fileName));
  MOCK_METHOD0(closeFile, int());
  MOCK_METHOD0(readLine, std::string());
  MOCK_METHOD0(endOfData, bool());
};

#endif /* FILEREADERMOCK_H_ */
</pre>
</li>
</ul>

Now we create the <em>FileWriterMock</em>.
<ul>
	<li>Add a new file <em>FileWriterMock.h</em> in the <em>mock</em> folder.</li>
	<li>Add the following code:
<pre>
#ifndef FILEWRITERMOCK_H_
#define FILEWRITERMOCK_H_

#include "gmock/gmock.h"
#include "AbstractFileWriterInterface.h"

class FileWriterMock : public AbstractFileWriterInterface {
public:
  MOCK_METHOD1(openFile, int(const std::string& fileName));
  MOCK_METHOD0(closeFile, int());
  MOCK_METHOD1(writeLine, void(const std::string& newLine));
  MOCK_METHOD0(lineFeed, void());
  MOCK_METHOD0(setEndOfData, void());
};

#endif /* FILEWRITERMOCK_H_ */
</pre>
</li>
</ul>


We can now write a test which makes use of the mock objects to verify that the <em>WordsrepClass</em> interacts with the file interfaces correctly.

The sequence diagram below shows how we want the <em>WordsrepClass</em> to interact with the file interfaces.

<center><a href="http://localhost/wordpress/wp-content/uploads/400_WordsrepClassFileInterfaceInteractions.png"><img class="alignnone size-medium wp-image-21" alt="400_WordsrepClassFileInterfaceInteractions.png" src="http://localhost/wordpress/wp-content/uploads/400_WordsrepClassFileInterfaceInteractions.png" /></a></center>

We will now write the test <em>InteractsCorrectlyWithFileInterfaces</em> where we will:
<ol>
<li>Set expectations upon <em>FileReaderMock</em> and <em>FileWriterMock</em> according to the functions calls in the sequence diagram above
<li>Call method <em>processInputFile</em> belonging to <em>WordsrepClass</em>.

The mock objects will make the test fail if the function calls from <em>WordsrepClass</em> do not occur according to the expectations we have put on them.

We use the Google Mock macro EXPECT_CALL to set expectations upon the mock objects.
<code>
EXPECT_CALL(<em>&lt;mock object></em>, <em>&lt;method name including argument></em>)
.Times(<em>&lt;how many times we expect the method to be called></em>)
.WillOnce(<em>&lt;what the method in the mock should return></em>);
</code>

Example:

<code>
EXPECT_CALL(fileReaderMock, openFile("a.txt"))
.Times(Exactly(1))
.WillOnce(Return(0));
</code>

We want some of the function calls to occur in a specific sequence. We use the following Google Mock syntax in the test to achieve this:

<code>
{
    InSequence s;

    EXPECT_CALL(...
    EXPECT_CALL(...
    EXPECT_CALL(...
}
</code>

<ul>
	<li>Add the following includes to <em>WordsrepClassTest.cpp</em>
<pre>
#include "FileReaderMock.h"
#include "FileWriterMock.h"
</pre>
<li>Add the following lines after the includes in <em>WordsrepClassTest.cpp</em>:
<pre>
using ::testing::Exactly;
using ::testing::Return;
using ::testing::InSequence;
</pre>
</li>
	<li>Add the following test to <em>WordsrepClassTest.cpp</em>
<pre>
TEST(WordsrepClassTest, InteractsCorrectlyWithFileInterfaces)
{
  //Setup
  FileReaderMock fileReaderMock;
  FileWriterMock fileWriterMock;
  WordsrepClass wordsrepClass;

  //Set expectations on mock objects
  EXPECT_CALL(fileReaderMock, openFile("a.txt"))
  .Times(Exactly(1))
  .WillOnce(Return(0));

  EXPECT_CALL(fileWriterMock, openFile("b.txt"))
  .Times(Exactly(1))
  .WillOnce(Return(0));

  {
    InSequence s;

    EXPECT_CALL(fileReaderMock, endOfData())
    .Times(Exactly(1))
    .WillOnce(Return(false));

    //Line 1
    EXPECT_CALL(fileReaderMock, readLine())
    .Times(Exactly(1))
    .WillOnce(Return("car house street"));

    EXPECT_CALL(fileWriterMock, writeLine("house house street"))
    .Times(Exactly(1));

    EXPECT_CALL(fileReaderMock, endOfData())
    .Times(Exactly(1))
    .WillOnce(Return(false));

    //Line 2
    EXPECT_CALL(fileReaderMock, readLine())
    .Times(Exactly(1))
    .WillOnce(Return("space blue cow"));

    EXPECT_CALL(fileWriterMock, lineFeed())
    .Times(Exactly(1));

    EXPECT_CALL(fileWriterMock, writeLine("space blue cow"))
    .Times(Exactly(1));

    EXPECT_CALL(fileReaderMock, endOfData())
    .Times(Exactly(1))
    .WillOnce(Return(true));
  }

  EXPECT_CALL(fileReaderMock, closeFile())
  .Times(Exactly(1))
  .WillOnce(Return(0));

  EXPECT_CALL(fileWriterMock, closeFile())
  .Times(Exactly(1))
  .WillOnce(Return(0));

  int argc = 9;
  const char * argv[] = {"wordsrep", "--oldWord", "car", "--newWord", "house", "--inputFile", "a.txt", "--outputFile", "b.txt"};

  //Exercise &amp; Verify
  wordsrepClass.processInputFile(argc, argv, fileReaderMock, fileWriterMock);
}
</pre>
</li>
</ul>

We must make the interfaces and mock objects available when building

<ul>
<li>Include the new interface folder into the build by adding the following line to the CMakeLists.txt in the project root folder:
<pre>
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/interface)
</pre>
Add the line directly after the other include_directories.
</li>
<li>Add the new mock folder to the test build by adding the following line to test/CMakeLists.txt:
<pre>
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/mock)
</pre>
Add the line together with the existing include_directories.
</li>
Build and run to make sure it fails. The build should fail because of missing member <em>processInputFile</em>.

Now we create method <em>processInputFile</em> in the WordsrepClass.
<ul>
	<li>Add the following includes to <em>WordsrepClass.h</em>:
<pre>
#include "AbstractFileReaderInterface.h"
#include "AbstractFileWriterInterface.h"
</pre>
</li>
	<li>Now add the prototype for the new public method:
<pre>
void processInputFile(int&amp; argc, const char* argv[], AbstractFileReaderInterface&amp; fileReader, AbstractFileWriterInterface&amp; fileWriter);
</pre>
</li>
<li>Add the following includes in <em>WordsrepClass.cpp</em>:
<pre>
#include "ArgumentParserClass.h"
#include "LineToWordsClass.h"
#include "WordsToLineClass.h"
</pre>
</li>
<li>The implementation of <em>processInputFile</em> looks like this:
<pre>
void WordsrepClass::processInputFile(int&amp; argc, const char* argv[],
		AbstractFileReaderInterface&amp; fileReader,
		AbstractFileWriterInterface&amp; fileWriter) {

  ArgumentParserClass argumentParserClass;
  LineToWordsClass lineToWordsClass;
  WordsToLineClass wordsToLineClass;

  auto oldWord = argumentParserClass.getSwitchValue(argc, argv, "--oldWord");
  auto newWord = argumentParserClass.getSwitchValue(argc, argv, "--newWord");
  auto inputFile = argumentParserClass.getSwitchValue(argc, argv, "--inputFile");
  auto outputFile = argumentParserClass.getSwitchValue(argc, argv, "--outputFile");


  fileReader.openFile(inputFile);
  fileWriter.openFile(outputFile);

  isFirstLine = true;
  while(false == fileReader.endOfData())
  {
    auto tempLine = fileReader.readLine();

    auto words = lineToWordsClass.splitLine(tempLine);
    auto newWords = this-&gt;replaceMatchingWords(oldWord, newWord, words);
    tempLine = wordsToLineClass.concatenateWords(newWords);

    insertLineFeed(fileWriter);
    fileWriter.writeLine(tempLine);
  }

  fileWriter.closeFile();

}
</pre>
</li>
<li> We must also implement the helper method <em>insertLineFeed</em>. We add a private section to the class definition in <em>WordsrepClass.h</em> first:
<pre>
private:
  void insertLineFeed(AbstractFileWriterInterface&amp; fileWriter);
  bool isFirstLine;
</pre>
</li>
<li>The method implementation in <em>WordsrepClass.cpp</em> looks like this:
<pre>
void WordsrepClass::insertLineFeed(AbstractFileWriterInterface&amp; fileWriter) {
  if(!isFirstLine) {
    fileWriter.lineFeed();
  }
  isFirstLine  = false;
}
</pre>
</li>
<li>Build and run tests.
<li>Hmm, we get the following failure:
<pre>
[ RUN      ] WordsrepClassTest.InteractsCorrectlyWithFileInterfaces
/home/tdd1/repos/tddcourse/reference/section13/WordsrepApp/test/WordsrepClassTest.cpp:65: Failure
Actual function call count doesn't match EXPECT_CALL(myFileReaderMock, closeFile())...
         Expected: to be called once
           Actual: never called - unsatisfied and active
[  FAILED  ] WordsrepClassTest.InteractsCorrectlyWithFileInterfaces (1 ms)
</pre>
Can you spot the error in the code?









<li>We have forgot to call closeFile on fileReader:
<pre>
fileReader.closeFile();
</pre>
Correct the code.
<li>Build and run to make sure the <em>InteractsCorrectlyWithFileInterfaces</em> test passes:
<pre>
[----------] 2 tests from WordsrepClassTest
[ RUN      ] WordsrepClassTest.ReplaceMatchingWordsWithNewWord
[       OK ] WordsrepClassTest.ReplaceMatchingWordsWithNewWord (0 ms)
[ RUN      ] WordsrepClassTest.InteractsCorrectlyWithFileInterfaces
[       OK ] WordsrepClassTest.InteractsCorrectlyWithFileInterfaces (1 ms)
[----------] 2 tests from WordsrepClassTest (1 ms total)
</pre>

</li>
</ul>


The test case <em>InteractsCorrectlyWithFileInterfaces</em> is quite long and hard to read. We can refactor the test case while under protection from the passing test case. One possible outcome is shown below. We make use of a fixture class WordsrepClassTest which inherits from Google Test class <em>Test</em>. We put a helper function called <em>setMockExpectations</em> in the fixture class. We also let the fixture class instantiate the mock objects and the WordsrepClass.

WordsrepClassTest.cpp
<pre>
#include "gmock/gmock.h"
#include "WordsrepClass.h"
#include "FileReaderMock.h"
#include "FileWriterMock.h"

using ::testing::Exactly;
using ::testing::Return;
using ::testing::InSequence;

class WordsrepClassTest : public ::testing::Test {
public:
	  FileReaderMock myFileReaderMock;
	  FileWriterMock myFileWriterMock;
	  WordsrepClass myWordsrepClass;

	  void setMockExpectations(std::string line1In, std::string line1Out, std::string line2In, std::string line2Out);
};

void WordsrepClassTest::setMockExpectations(std::string line1In, std::string line1Out, std::string line2In, std::string line2Out)
{
	//Set expectations on mock objects
	EXPECT_CALL(myFileReaderMock, openFile("a.txt"))
	.Times(Exactly(1))
	.WillOnce(Return(0));

	EXPECT_CALL(myFileWriterMock, openFile("b.txt"))
	.Times(Exactly(1))
	.WillOnce(Return(0));

	{
	InSequence s;

	EXPECT_CALL(myFileReaderMock, endOfData())
	.Times(Exactly(1))
	.WillOnce(Return(false));

	//Line 1
	EXPECT_CALL(myFileReaderMock, readLine())
	.Times(Exactly(1))
	.WillOnce(Return(line1In));

	EXPECT_CALL(myFileWriterMock, writeLine(line1Out))
	.Times(Exactly(1));

	EXPECT_CALL(myFileReaderMock, endOfData())
	.Times(Exactly(1))
	.WillOnce(Return(false));

	//Line 2
	EXPECT_CALL(myFileReaderMock, readLine())
	.Times(Exactly(1))
	.WillOnce(Return(line2In));

	EXPECT_CALL(myFileWriterMock, lineFeed())
	.Times(Exactly(1));

	EXPECT_CALL(myFileWriterMock, writeLine(line2Out))
	.Times(Exactly(1));

	EXPECT_CALL(myFileReaderMock, endOfData())
	.Times(Exactly(1))
	.WillOnce(Return(true));
	}

	EXPECT_CALL(myFileReaderMock, closeFile())
	.Times(Exactly(1))
	.WillOnce(Return(0));

	EXPECT_CALL(myFileWriterMock, closeFile())
	.Times(Exactly(1))
	.WillOnce(Return(0));
}

TEST_F(WordsrepClassTest, ReplaceMatchingWordsWithNewWord)
{
  //Setup
  WordsrepClass wordsrepClass;

  std::vector&lt;std::string&gt; words;
  words.push_back("table");
  words.push_back("rocket");
  words.push_back("moon");

  std::string oldWord("table");
  std::string newWord("sun");

  std::vector&lt;std::string&gt; newWords;

  //Exercise
  newWords = wordsrepClass.replaceMatchingWords(oldWord, newWord, words);

  //Verify
  ASSERT_EQ("sun",    newWords[0]);
  ASSERT_EQ("rocket", newWords[1]);
  ASSERT_EQ("moon",   newWords[2]);
}

TEST_F(WordsrepClassTest, InteractsCorrectlyWithFileInterfaces)
{
  //Set expectations on mock objects
  std::string line1In("car house street");
  std::string line1Out("house house street");
  std::string line2In("space blue cow");
  std::string line2Out("space blue cow");

  setMockExpectations(line1In, line1Out, line2In, line2Out);

  int argc = 9;
  const char * argv[] = {"wordsrep", "--oldWord", "car", "--newWord", "house", "--inputFile", "a.txt", "--outputFile", "b.txt"};

  //Exercise &amp; Verify
  myWordsrepClass.processInputFile(argc, argv, myFileReaderMock, myFileWriterMock);
}
</pre>

<h3>Implement the real file line reader and writer</h3>
Ok, we have implemented all our tests needed to test drive the basic functionality of the WordsrepApp. However we also want to test the actual command line tool. We must create a second main.cpp file to use when building the command line tool and not the unit tests. But we must start with implementing the FileReaderClass and FileWriterClass to interact with the actual file system.

We don't unit test this part of the code. But by minimizing the <em>glue</em> code between the WordsrepApp core functionality and the actual file system we are allowed to unit test as much as possible of the code.
<ol>
<li>Create a new file <em>FileReaderClass.h</em> in the <em>src</em> folder</li>
<li>Add the following code:
<pre>
#ifndef FILEREADERCLASS_H_
#define FILEREADERCLASS_H_

#include "AbstractFileReaderInterface.h"
#include &lt;iostream&gt;
#include &lt;fstream&gt;

class FileReaderClass : public AbstractFileReaderInterface {
private:
std::ifstream myFile;

public:
  int openFile(const std::string&amp; fileName);
  int closeFile();
  std::string readLine();
  bool endOfData();

};

#endif /* FILEREADERCLASS_H_ */
</pre>
</li>
<li>Create a new file <em>FileReaderClass.cpp</em> in the <em>src</em> folder</li>
<li>Add the following code:
<pre>
#include "FileReaderClass.h"

int FileReaderClass::openFile(const std::string&amp; fileName) {
  auto fileNameChar_p = fileName.c_str();
  this-&gt;myFile.open(fileNameChar_p, std::fstream::in);
  return 0;
}

std::string FileReaderClass::readLine() {
  const int MAXLENGTH = 500;
  char rad[MAXLENGTH+1];
  this-&gt;myFile.getline(rad, MAXLENGTH);
  return std::string(rad);
}

bool FileReaderClass::endOfData() {
  return this-&gt;myFile.eof();
}

int FileReaderClass::closeFile()
{
  this-&gt;myFile.close();
  return 0;
}
</pre>
</li>
<li>Create a new file <em>FileWriterClass.h</em> in the <em>src</em> folder</li>
<li>Add the following code:
<pre>
#ifndef FILEWRITERCLASS_H_
#define FILEWRITERCLASS_H_

#include "AbstractFileWriterInterface.h"
#include &lt;iostream&gt;
#include &lt;fstream&gt;

class FileWriterClass : public AbstractFileWriterInterface {
private:
  std::ofstream myFile;

public:
  int openFile(const std::string&amp; fileName);
  int closeFile();
  void writeLine(const std::string&amp; line);
  void lineFeed();
  void setEndOfData();

};

#endif /* FILEWRITERCLASS_H_ */
</pre>
</li>
<li>Create a new file <em>FileWriterClass.cpp</em> in the <em>src</em> folder</li>
<li>Add the following code:
<pre>
#include "FileWriterClass.h"

int FileWriterClass::openFile(const std::string&amp; fileName) {
  auto fileNameChar_p = fileName.c_str();
  this-&gt;myFile.open(fileNameChar_p);
  return 0;
}

int FileWriterClass::closeFile() {
  this-&gt;myFile.close();
  return 0;
}

void FileWriterClass::writeLine(const std::string&amp; line) {
  this-&gt;myFile << line;
}

void FileWriterClass::lineFeed() {
	this-&gt;myFile << '\n';
}

void FileWriterClass::setEndOfData() {
  this-&gt;closeFile();
}
</pre>
</li>
</ol>
<h3>Compile command line application</h3>
We must add a new <em>main.cpp</em> to run the <em>WordsrepApp</em> from the command line. We must also configure the cmake to create a separate build with the new <em>main.cpp</em>.
<ol>
<li>Add a new file <em>main.cpp</em> in the <em>src</em> folder</li>
<li>Add the following code
<pre>
#include "WordsrepClass.h"
#include "FileReaderClass.h"
#include "FileWriterClass.h"

int main(int argc, const char * argv[])
{
  FileReaderClass fileReaderClass;
  FileWriterClass fileWriterClass;
  WordsrepClass wordsrepClass;

  wordsrepClass.processInputFile(argc, argv, fileReaderClass, fileWriterClass);

  return 0;
}
</pre>
</li>
<li>Add the following two lines to the end of the CMakeLists.txt in the project root folder:
<pre>
#The add_executable command tells CMake to create a binary
#The first argument is the name of the binary to create, the
#rest are source files. Header files are not included in this
#command. 
add_executable(wordsrepapp ${CMAKE_CURRENT_SOURCE_DIR}/src/main.cpp)


#target_link_libraries specifies libraries or flags to use 
#when linking a given target. The named target (first 
#argument) must have been created in the current directory
#with add_executable() or add_library()
target_link_libraries(wordsrepapp src)
</pre>
</li>
<li>
Edit the add_library command in src/CMakeLists.txt so it looks like this:
<pre>
add_library(src ArgumentParserClass.cpp LineToWordsClass.cpp WordsToLineClass.cpp WordsrepClass.cpp FileReaderClass.cpp FileWriterClass.cpp)
</pre>
</li>
<li>Build the project</li>
<li>Check that you have the wordsrepapp binary in the build folder after building</li>
</ol>
Now we want test our command line utlity!
<ol>
	<li>Click on Start menu - Accessories - LXTerminal</li>
	<li>Change folder to your WordsrepApp git repository
<pre>
cd /home/tdd1/git/WordsrepAppGit/WordsrepApp/
</pre>
</li>
<li>Go into the <em>build</em> folder
<pre>
cd build 
</pre>
</li>
<li>You should have the <em>wordsrepapp</em> binary in the <em>build</em> folder</li>
<li>Create a text file <em>a.txt</em> containing the following lines:
<pre>
house car space
cycle table chair
</pre>
By running:
<pre>
echo "house car space" >> a.txt
echo "cycle table chair" >> a.txt
</pre>
<li>Execute the WordsrepApp:
<pre>
./wordsrepapp --oldWord car --newWord black --inputFile a.txt --outputFile b.txt</pre>
</li>
<li>Check the output by executing:
<pre>cat b.txt</pre>
</li>
<li>You should get:
<pre>
house black space
cycle table chair
</pre>
</li>
</ol>
<h3>Connect Google Tests to a Continuous Integration Server</h3>
Finally we will connect our tests to a continuous integration server, in this case Jenkins.

There is a reference project, <a href="http://localhost/jenkins/job/WordsrepAppReferenceTestsCmake/" title="WordsrepAppReferenceTestsCmake" target="_blank">WordsrepAppReferenceTestsCmake</a>, setup in Jenkins which you can look at it if you run into problems when performing the steps below.

<ol>
	<li>Make sure you have added and commited all your files to git</li>
	<li>Go to <code>localhost/jenkins</code> in the webbrowser</li>
	<li>Click on New Job</li>
	<li>Enter job name <code>WordsrepAppTests</code><center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Screenshot_jenkins_job_name.png" /></center></li>
	<li>Select <em>Build a free-style software project</em> and click OK</li>
	<li>Select <em>Git</em> in section <em>Source Code Management</em></li>
	<li>Enter <em>Repository URL</em>:
<pre>
/home/tdd1/git/WordsrepAppGit/.git
</pre>
</li>
	<li>Click on <em>Add build step</em> in section <em>Build</em> and select <em>Execute shell</em></li>
	<li>Paste the following in the Command box:
<pre>
cd WordsrepApp/
mkdir -p build
cd build
cmake ..
make
./test/wordsrepapptest --gtest_output="xml:WordsRepApp_TestResults.xml"
</pre>
</li>
<li>Click on <em>Add post-build action</em> in section <em>Post-build Actions</em> and select <em>Publish JUnit test result report</em></li>
	<li>Enter the following in box <em>Test report XMLs</em>: 
<pre>
WordsrepApp/build/WordsRepApp_TestResults.xml
</pre>
</li>
        <li>Click on Apply
	<li>Click on Save</li>
	<li>Click on <em>Build now</em>
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Screenshot_jenkins_build_now.png" /></center></li>
	<li>The build history should show the first job as blue after some time, indicating that the build went fine and all tests passed:
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Screenshot_jenkins_build_history.png" /></center></li>
	<li>Click on the job in the Build History</li>
	<li>Click on <em>Test result</em></li>
	<li>Click on <em>(root)</em></li>
	<li>You should now get a list of all test classes with corresponding test results
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Section16_Jenkins_Test_Classes.png" /></center></li>
	<li>Click on <em>WordsrepClassTest</em> to get the results of each test in that test class
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Section16_Jenkins_Test_Results.png" /></center></li>
</ol>
The Jenkins job we have created is now setup to run when manually triggered. It is also possible to setup the job to be triggered automatically.

<h3>Test drive dynamic word delimiter</h3>

You have fulfilled all the original requirements on the <strong>wordsrep</strong> application. However now we have a new requirement coming in. The customers want to specify what delimiter to use between words. The delimiter can no longer be hardcoded to space. It should now be possible to run wordsrep with the new argument <em>--wordDelimiter</em>.

[table id=4 /]

<strong>Example</strong>
To set the delimiter to # we run wordsrep like this:
<pre>./wordsrepapp --oldWord car --newWord house --inputFile a.txt --outputFile b.txt --wordDelimiter \#</pre>
The backslash is needed to tell the Bash to not interpret # as the start of a comment.

a.txt
<pre>
car#horse#tree
</pre>

b.txt
<pre>
house#horse#tree
</pre>

You must implement the following tests to add support for setting the wordDelimiter:
[table id=5 /]

<strong>LineToWordsClass</strong>

The <em>LineToWordsClass</em> must implement a new method <code>setWordDelimiter</code>. It should be possible to set a word delimiter of one character using the new method. The new test <em>CanSplitLineUsingDynamicWordDelimiter</em> shall verify that a new delimiter can be set and also used to split up a line into words.

<strong>WordsToLineClass</strong>

The <em>WordsToLineClass</em> must also implement a new method <code>setWordDelimiter</code> with similar purpose as in <em>LineToWordsClass</em>. The new test <em>ConcatenateWordsUsingDynamicWordDelimiter</em> shall verify that a new delimiter can be set and also used to concatenate words into a line.

<strong>WordsrepClass</strong>

The <em>processInputFile</em> method in <em>WordsrepClass</em> must now check whether the <em>wordDelimiter</em> argument has been specified at the command line. It must then pass the new word delimiter onto the other classes via the <code>setWordDelimiter</code> methods. The new test <em>CanUseNonSpaceWordDelimiter</em> shall verify that we can now make use of the new argument <em>wordDelimiter</em>.

Remember that you can check the reference project if you get stuck while test driving the new functionality:
<pre>/home/tdd1/workspace_reference</pre>
The <em>WordsrepClassTest</em> has been cleaned up in the reference project and makes use of the fixture class to avoid duplication when settting mock expectations.

<h3>About this course</h3>

This course was created with <em>passion</em> and some degree of <em>innovation</em>. I now <em>trust</em> you to give me feedback so that it can be continuously improved. ;)

jacob.mossberg@cybercom.com
twitter.com/jcmossberg

<a href="http://localhost/wordpress/wp-content/uploads/jacobmossberg.jpg"><img class="alignnone size-medium wp-image-21" src="http://localhost/wordpress/wp-content/uploads/jacobmossberg.jpg" width="150" /></a>
