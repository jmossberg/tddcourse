Welcome to this course in Test Driven Development. We will develop a command line tool called <strong>WordsRep</strong> using Test Driven Development methods.

[toc]
<h3>Introduction to Test Driven Development</h3>
Test Driven Development (TDD) is a software development technique where we grow the design by writing unit tests before writing the actual software. We work in an iterative way. This means that we will:
<ol>
	<li>Write a small test</li>
	<li>Make sure it fails</li>
	<li>Make it pass</li>
	<li>Refactor (which means to clean up the code)</li>
</ol>
We can grow the software inside-out (Classic TDD) or outside-in (London TDD):
<ul>
	<li>We start with the core algorithms and work our way out to the public interface of our application when we do <strong>inside-out</strong>(Classic TDD).</li>
	<li>We start with the public interface and work our way in to the core algorithms when we do <strong>outside-in</strong>(London TDD).</li>
</ul>
London TDD will require us to make extensive use of test doubles. Test doubles are stand ins for the real objects. Since the core objects do not yet exist when we start with the public interface we must fake them.

<a href="http://localhost/wordpress/wp-content/uploads/100_InsideOutVsOutsideIn.png"><img class="alignnone size-medium wp-image-21" alt="100_InsideOutVsOutsideIn" src="http://localhost/wordpress/wp-content/uploads/100_InsideOutVsOutsideIn.png" /></a>

We will use inside-out (Classic TDD) when developing the WordsRep application.

The diagram below shows how to design our software to make use of test doubles. The client class depends on an interface expressed using an abstract class. The interface can be implemented by a real class or by a test double. The ClientClass will be satisfied as long as the abstract interface is fulfilled.

<center><a href="http://localhost/wordpress/wp-content/uploads/200_TestDoubles.png"><img class="alignnone size-medium wp-image-21" alt="200_TestDoubles.png" src="http://localhost/wordpress/wp-content/uploads/200_TestDoubles.png" /></a></center>We must design the ClientClass so that we can provide a pointer to either the test double or the real class. We call this dependency injection.

There are different types of test doubles. Gerard Meszaros defines them as follows in his book ''xUnit Test Patterns'':

[table id=1 /]
<h3>Introduction to Google Test</h3>
Google Test can be used to write unit tests. Google Test is written in C++. Google Mock is an addon to Google Test which automates the process of creating mock objects somewhat.

Below is an example of a test written for Google Test/Google Mock.

<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/GoogleTestStructure.png" /></center>We verify that the method <em>getNameLength()</em> returns the correct length of the name that has been stored in the class Person. The test is part of test fixture class <em>PersonTest</em>. A fixture class can be used to initialize objects needed by several tests belonging to the same fixture class.

We use a four phase pattern when writing the test:
<ul>
	<li>Setup phase - prepare all objects needed</li>
	<li>Excercise phase - here we excercise the code we want to verify in this particular test</li>
	<li>Verify phase - we verify the outcome</li>
	<li>Teardown phase - we clean up objects</li>
</ul>
We must also create a ''main.cpp'' that runs the Google Test/Google Mock:
<pre>#include "gmock/gmock.h"

int main(int argc, char* argv[]) {
  ::testing::InitGoogleMock(&amp;argc, argv);
  return RUN_ALL_TESTS();
}</pre>
<h3>The Word Replace tool - WordsRep</h3>
We will develop a command line tool called <strong>WordsRep</strong> in this course. The WordsRep tool searches each line in a text file for a specific word and replaces with another word. The output is written to a new file. Space is the delimiter separating words from one another.

It should accept the following arguments:

[table id=2 /]

<strong>Example 1</strong>
<pre>wordsrep --oldWord car --newWord house --inputFile a.txt --outputFile b.txt</pre>
a.txt
<em>car</em> house street
space blue cow

b.txt
<em>house</em> house street
space blue cow

<strong>Example 2</strong>
<pre>wordsrep --oldWord car --newWord house --inputFile a.txt --outputFile b.txt</pre>
a.txt
<em>car</em> car2 street

b.txt
<em>house</em> car2 street
<h3>The WordsRep reference project</h3>
A WordsRep reference project is available in:
<pre>/home/tdd1/workspace_reference</pre>
You can open this project in Eclipse if you get stuck while doing the exercises below. The reference project contains the full WordsRep application after the excercise below have been completed. Take a look at the reference project to get <em>unstuck</em> and continue with your own workspace again.
<h3>Create a new C++ project in Eclipse CDT and connect to Git repository</h3>
We will create a C++ project in Eclipse CDT to develop our WordsRep application.
<ol>
	<li>Start Eclipse CDT</li>
	<li>Select workspace "/home/tdd1/workspace"</li>
	<li>Close the Welcome screen</li>
	<li>Select "File - New - Other..."</li>
	<li>Select "C/C++ - C++ Project"</li>
	<li>Enter Project Name: ''WordsrepApp''</li>
	<li>Select Project Type ''Makefile project - Empty Project'' and toolchain ''Linux GCC''</li>
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Section5_Eclipse_New_Project.png" /></center>
	<li>Click "Finish"</li>
	<li>Select Yes if asked to open the C/C++ perspective</li>
	<li>Now let's connect the project to a Git repository by right clicking on it and selecting "Team - Share Project...<br>
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Screenshot_team_share_project.png" /></center></li>
	<li>Select Git and click Next</li>
	<li>Click on Create...</li>
	<li>Enter parent directory:
<pre>/home/tdd1/git</pre>
</li>
	<li>Enter name: WordsrepAppGit</li>
	<li>Click Finish</li>
	<li>Click Finish again</li>
</ol>
<h3>Build Google Test and Google Mock in Eclipse using CMake</h3>
Now we will import Google test and Google mock into our Eclipse project and build them with a minimalistic main file.
<ol>
	<li>Right click on the <em>WordsrepApp</em> project in Project Explorer and select New - Folder</li>
	<li>Enter folder name <em>google</em> and click Finish</li>
	<li>Right click on the <em>google</em> folder and select Import...</li>
	<li>Select General - File system and click Next</li>
	<li>Click Browse...</li>
	<li>Select folder /home/tdd1/google and click OK</li>
	<li>Check the google folder and click Finish</li>
        <li>You should now have a gmock-1.7.0 inside the google folder in the Project Explorer</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and choose "Team - Add to Index"</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and choose "Team - Commit"</li>
	<li>Enter message "Add Google Mock" and click "Commit"</li>
	<li>We have now added the Google Mock files to the git repository</li>
	<li>Create a new folder <em>test</em> by right clicking on WordsrepApp and selecting New - Folder</li>
	<li>Right click on the <em>test</em> folder and select New - Source File</li>
	<li>Enter name <em>main.cpp</em> and click on Finish</li>
	<li>Add the following code to <em>main.cpp</em> and save:
<pre>
#include "gmock/gmock.h"

int main(int argc, char* argv[]) {
  ::testing::InitGoogleMock(&amp;argc, argv);
  return RUN_ALL_TESTS();
}
</pre>
</li>
	<li>Right click on the WordsrepApp project and select New - File</li>
	<li>Select WordsrepApp root folder as Parent Directory, enter name "CMakeLists.txt" and click Finish</li>
	<li>Add the following to the <em>CMakeLists.txt</em> and save:
<pre>
cmake_minimum_required(VERSION 2.8)

project("WordsRepAppProj")

add_definitions(-Wall -g3 -std=c++11)

include_directories(${CMAKE_CURRENT_SOURCE_DIR})

add_subdirectory(test)
</pre>	
</li>
	<li>Create another CMakeLists.txt file inside the test folder</li>
	<li>Add the following to the CMakeLists.txt file inside the test folder
<pre>
set(GMOCK_DIR "../google/gmock-1.7.0"
    CACHE PATH "The path to the GoogleMock test framework.")

add_subdirectory(${GMOCK_DIR} {CMAKE_BINARY_DIR}/gmock)

include_directories(SYSTEM ${GMOCK_DIR}/gtest/include
                           ${GMOCK_DIR}/include)

include_directories(${CMAKE_SOURCE_DIR}/test)

add_executable(wordsrepapptest main.cpp)

target_link_libraries(wordsrepapptest gmock_main)
</pre>
</li>
	<li>Create a new folder <em>build</em> by right clicking on WordsrepApp and selecting New - Folder</li>
	<li>Right click on the build folder and choose "Team - Ignore"</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and choose "Team - Add to Index"</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and choose "Team - Commit"</li>
	<li>Enter message "Import Google Mock and configure build with CMake". Click Commit.</li>
	<li>Now we will create a Make Target to generate the Makefiles from the CMakeLists.txt files.</li>
	<li>Select the <em>Make Target</em> tab on the right side of Eclipse</li>
	<li>Expand the <em>WordsrepApp</em> project and right click on the <em>build</em> folder</li>
	<li>Click on New...</li>
	<li>Enter <em>Target name</em>: cmake</li>
	<li>Uncheck <em>Same as the target name</em></li>
	<li>Enter <em>Build command</em>: cmake ..
	<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Section6_Modify_Make_Target.png" /></center></li>
	<li>Click on OK</li>
	<li>Double-click on the new Make Target cmake. Some files and folders shall be generated in the build folder. You can verify this in the Project Explorer on the left side of Eclipse.</li>
	<li>Now we will configure some WordsrepApp project settings so that we can build</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and select Properties</li> 
	<li>Go to "C/C++ Build", select tab "Builder Settings" and click on Workspace... button</li>
	<li>Expand the folder tree and select the build folder. Click OK</li>
	<li>Click on Apply</li>
	<li>Click on OK to exit the project properties for WordsrepApp</li>
	<li>Select menu Project - Build Project</li>
	<li>Select menu Run - Run Configurations...</li>
	<li>Select <em>C/C++ Application</em> on the left and click on the <em>New</em> button</li>
	<li>Enter Name: WordsrepAppConsole</li>
	<li>Click on button <em>Search Project...</em> and select <em>wordsrepapptest</em>. Click OK.</li>
	<li>You should now have <em>build/test/wordsrepapptest</em> in the <em>C/C++ Application</em> field
	<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Section6_Run_Configurations.png" /></center></li>
	<li>Click on Apply and then on Run</li>
	<li>You should get the following in the Console tab:
<pre>
[==========] Running 0 tests from 0 test cases.
[==========] 0 tests from 0 test cases ran. (0 ms total)
[  PASSED  ] 0 tests.
</pre>
</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and choose "Team - Add to Index"</li>
	<li>Right click on the WordsrepApp project in the Project Explorer and choose "Team - Commit"</li>
	<li>Enter message "Update Eclipse project settings to build WordsrepApp with CMake". Click Commit.</li>
</ol>

<h3>Add dummy test</h3>
We will add a dummy test to show the basic structure of a test.
<ol>
	<li>Right click on the test folder and select "New - Source File"</li>
	<li>Enter source file name <em>DummyTest.cpp</em> and click "Finish"</li>
	<li>Each test class has to include Google Test and Google Mock.</li>
	<li>Add the following at the top of <em>DummyTest.cpp</em>
<pre>#include "gmock/gmock.h"</pre>
</li>
	<li>Now we add the code for the dummy test.
<pre>TEST(DummyTest, APassingTest) {
  ASSERT_TRUE(true);
}</pre>
</li>
	<li><em>DummyTest.cpp</em> shall now look like this:
<pre>
#include "gmock/gmock.h"

TEST(DummyTest, APassingTest) {
  ASSERT_TRUE(true);
}
</pre>
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/dummy_test.png" /></center></li>
	<li>Save</li>
	<li>Add the new source file to the following line in the CMakeLists.txt file in the test folder:
<pre>
add_executable(wordsrepapptest main.cpp)
</pre>
so that it looks like this
<pre>
add_executable(wordsrepapptest main.cpp DummyTest.cpp)
</pre>
</li>
	<li>Save the CMakeLists.txt file</li>
	<li>Double click on the cmake target in the Make Target tab on the right side of Eclipse. The purpose is to update the Makefiles with the new source file.
	<li>Select Project - Build Project</li>
	<li>Click on Run</li>
	<li>The console output shall now show our first test passing:
<pre>
[==========] Running 1 test from 1 test case.
[----------] Global test environment set-up.
[----------] 1 test from DummyTest
[ RUN      ] DummyTest.APassingTest
[       OK ] DummyTest.APassingTest (0 ms)
[----------] 1 test from DummyTest (0 ms total)

[----------] Global test environment tear-down
[==========] 1 test from 1 test case ran. (2 ms total)
[  PASSED  ] 1 test.
</pre>
</li>
	<li>Right click on the project and choose "Team - Add to Index"</li>
	<li>Right click on the project and choose "Team - Commit..."</li>
	<li>Enter message "Add dummy test" and click "Commit"</li>
	<li>You can continue to do git commit like this when you feel appropriate</li>
</ol>
<h3>A test list</h3>
We can compose an initial list of the tests we want to write based on what we know about <strong>WordsRep</strong>.
<ul>
	<li>retrieve the value of an argument switch</li>
	<li>split a line of text into words</li>
	<li>concatenate words into a line of text</li>
	<li>replace all matching words with replacement word</li>
</ul>
We should not spend too much time thinking about this list. The purpose is to get us going.
<h3>Retrieve the value of an argument switch</h3>
WordsRep is a command line tool which means all arguments will be supplied through the main function:
<pre>int main(int argc, char* argv[]) {</pre>
<ul>
	<li><code>argc</code> - argument counter</li>
	<li><code>argv</code> - argument vector</li>
</ul>
<em>argc</em> and <em>argv</em> will assume values according to the table below if we call WordsRep like this:
<pre>wordsrep --oldWord car</pre>
[table id=3 /]

Let's test drive an <em>ArgumentParserClass</em> which will let us parse command line arguments. We write a test to verify that we can retrieve the value of argument switches.
<ol>
	<li>Create a new file, ArgumentParserClassTest.cpp, in the test folder.</li>
	<li>Add the following to the new file:
<pre>
#include "gmock/gmock.h"
#include "ArgumentParserClass.h"

TEST(ArgumentParserClassTest, ValueOfArgumentSwitchCanBeRetrieved) {

  //Setup
  ArgumentParserClass argumentParserClass;

}
</pre>
The test is not finished but we can stop writing here and try to build.
</li>
<li>Add <em>ArgumentParserClassTest.cpp to the following line in test/CMakeLists.txt:
<pre>
add_executable(wordsrepapptest main.cpp DummyTest.cpp)
</pre>
<li>Double-click on the cmake target in the Make Target tab to update Makefiles</li>
<li>Build project via menu Project - Build Project</li>
<li>The build is failing since we have not implemented ArgumentParserClass. So let's implement an empty ArgumentParserClass.
<li>Add a <em>src</em> folder in the WordsrepApp project by right clicking on the project in the Project Explorer and selecting New - Folder</li>
<li>Create a new file, ArgumentParserClass.h, in the src folder.</li>
<li>The new header file shall contain:
<pre>
#ifndef ARGUMENTPARSERCLASS_H_
#define ARGUMENTPARSERCLASS_H_

class ArgumentParserClass {

};

#endif /* ARGUMENTPARSERCLASS_H_ */
</pre>
</li>
<li>Now we include the <em>src</em> folder when building.</li>
<li>Add the following line in the CMakeLists.txt file in the project root folder:
<pre>
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/src)
</pre>
so that the CMakeLists.txt file looks like this:
<pre>
cmake_minimum_required(VERSION 2.8)

project("WordsRepAppProj")

add_definitions(-Wall -g3 -std=c++11)

include_directories(${CMAKE_CURRENT_SOURCE_DIR})
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/src)

add_subdirectory(test)
</pre>
<li>Double-click on the cmake target in the Make Target tab to update Makefiles</li>
<li>Build project via menu Project - Build Project</li>
<li>Now the project shall build but with a warning about unused variable</li>

----------- I stopped working here on 2014-08-26 21:56 ------------



	<li>Right click on the <em>test</em> folder and select Properties</li>
	<li>Select C/C++ Build - Settings</li>
	<li>Goto Tool Settings - GCC C++ Compiler - Includes</li>
	<li>Click on Add.. in Include paths</li>
	<li>Click on Workspace...</li>
	<li>Select the <em>src</em> folder and click OK multiple times to close all windows</li>
</li>
	<li>Build the project again. Now it should work.</li>
</ol>
You can adjust your coding "speed" based on your experience and the difficulty of the problem at hand. It is not necessary to always halt the writing of a test like this, but I wanted to show that you can go very slow when you are on unfamiliar territory.

Let's finish the test:
<pre>TEST_F(ArgumentParserClassTest, ValueOfArgumentSwitchCanBeRetrieved) {

  //Setup
  int argc { 3 };
  const char * argv[] = {"wordsrep", "--oldWord", "car"};
  ArgumentParserClass argumentParserClass;

  //Exercise
  std::string argumentSwitchValue = argumentParserClass.getSwitchValue(argc, argv, "--oldWord");

  //Verify
  ASSERT_EQ("car", argumentSwitchValue);
}</pre>
So what we do here is to setup a scenario where we have 3 arguments (the name of the program, in this case <em>wordsrep</em>, is the first argument). The second argument is a switch, marked with <code>--</code>. We want the <em>getSwitchValue</em> method to return the value after the switch, in this case <em>car</em>.

Build. It should fail because of the missing <em>getSwitchValue</em> method.

Now we implement it.
<ol>
	<li>Edit ArgumentParserClass.h to look like this:
<pre>
#ifndef ARGUMENTPARSERCLASS_H_
#define ARGUMENTPARSERCLASS_H_

#include &lt;string&gt;

class ArgumentParserClass {

public:
  std::string getSwitchValue(const int& argc, const char* argv[], const std::string& switchName);
};

#endif /* ARGUMENTPARSERCLASS_H_ */
</pre>
</li>
	<li>Add a new file ArgumentParserClass.cpp in src folder.</li>
	<li>Add the following:
<pre>#include "ArgumentParserClass.h"

std::string ArgumentParserClass::getSwitchValue(const int& argc, const char* argv[], const std::string& switchName)
{
  return "car";
}</pre>
</li>
</ol>
Build and run test to make sure the test pass:
<pre>[----------] 1 test from ArgumentParserClassTest
[ RUN      ] ArgumentParserClassTest.
             ValueOfArgumentSwitchCanBeRetrieved
[       OK ] ArgumentParserClassTest.
             ValueOfArgumentSwitchCanBeRetrieved (0 ms)
[----------] 1 test from ArgumentParserClassTest (0 ms total)</pre>
But the response of getSwitchValue is hardcoded. Let's extend the test to force some logic into the implementation:
<pre>TEST_F(ArgumentParserClassTest, ValueOfArgumentSwitchCanBeRetrieved) {

  //Setup
  int argc { 3 };
  const char * argv1[] = {"wordsrep", "--oldWord", "car"};
  const char * argv2[] = {"wordsrep", "--oldWord", "space"};
  ArgumentParserClass argumentParserClass;

  //Exercise
  std::string argumentSwitchValue1 =   argumentParserClass.getSwitchValue(argc, argv1, "--oldWord");
  std::string argumentSwitchValue2 = argumentParserClass.getSwitchValue(argc, argv2, "--oldWord");

  //Verify
  ASSERT_EQ("car", argumentSwitchValue1);
  ASSERT_EQ("space", argumentSwitchValue2);
}</pre>
Make sure the test fails. You should get this in the Console output:
<pre>[ RUN      ] ArgumentParserClassTest.ValueOfArgumentSwitchCanBeRetrieved
../test/ArgumentParserClassTest.cpp:22: Failure
Value of: argumentSwitchValue2
  Actual: "car"
Expected: "space"
[  FAILED  ] ArgumentParserClassTest.ValueOfArgumentSwitchCanBeRetrieved (0 ms)</pre>
So the test expected <em>space</em> to be returned but got <em>car</em>.
Now we put some logic into ''getSwitchValue'':
<pre>
#include "ArgumentParserClass.h"

std::string ArgumentParserClass::getSwitchValue(const int& argc, const char* argv[], const std::string& switchName)
{
  int i;

  for(i = 0; i &lt; argc; i++)
  {
    if(0 == switchName.compare(argv[i]))
    {
      return argv[i];
    }
  }

  return "";
}
</pre>

Build and run the test.

Hmm, the test still fails with the following output.

<pre>
[==========] Running 1 test from 1 test case.
[----------] Global test environment set-up.
[----------] 1 test from ArgumentParserClassTest
[ RUN      ] ArgumentParserClassTest.ValueOfArgumentSwitchCanBeRetrieved
../test/ArgumentParserClassTest.cpp:21: Failure
Value of: argumentSwitchValue1
  Actual: "--oldWord"
Expected: "car"
[  FAILED  ] ArgumentParserClassTest.ValueOfArgumentSwitchCanBeRetrieved (0 ms)
[----------] 1 test from ArgumentParserClassTest (0 ms total)
</pre>

The <em>getSwitchValue</em> returned the value <em>--oldWord</em>, but the test expects <em>car</em> to be returned.

Can you spot the error in the code?

The code below has been corrected.

<pre>
#include "ArgumentParserClass.h"

std::string ArgumentParserClass::getSwitchValue(const int& argc, const char* argv[], const std::string& switchName)
{
int i;

  for(i = 0; i &lt; argc; i++)
  {
    if(0 == switchName.compare(argv[i]))
    {
      return argv[i + 1];
    }
  }

  return "";
}
</pre>

Build and run the test again. Now it should pass.

<h3>Split a line of text into words</h3>
We have implemented the first test on the test list.
<ul>
	<li><span style="text-decoration: line-through;">retrieve the value of an argument switch</span></li>
	<li>split a line of text into words</li>
	<li>concatenate words into line of text</li>
	<li>replace all matching words with replacement word</li>
</ul>
Now we want to test drive how to split a line of text into words. Space is the delimeter used by wordsrep. So everything between two spaces is a word.

We have four words in the following example line:
<pre>car house fire moon_sun</pre>
<ul>
	<li>car</li>
	<li>house</li>
	<li>fire</li>
	<li>moon_sun</li>
</ul>
Let's implement a <em>LineToWordsClass</em> to help us split a line of text into words.

We start with a test.
<ol>
	<li>Add a new file <em>LineToWordsClassTest.cpp</em> in the <em>test</em> folder</li>
	<li>Add the following code:
<pre>
#include "gmock/gmock.h"
#include "LineToWordsClass.h"

//Empty test fixture class LineToWordsClassTest
class LineToWordsClassTest : public ::testing::Test
{

};

TEST_F(LineToWordsClassTest, CanSplitLineWithTwoWords)
{
  //Setup
  LineToWordsClass lineToWordsClass;
  std::vector&lt;std::string&gt; words;

  //Exercise
  words = lineToWordsClass.splitLine("street sky");

  //Verify
  ASSERT_EQ(2, words.size());
  ASSERT_EQ("street", words[0]);
  ASSERT_EQ("sky", words[1]);
}
</pre>
About the <em>vector</em> type from <em>www.cplusplus.com</em>:
<blockquote style="font-size: medium">Vectors are sequence containers representing arrays that can change in size.

Just like arrays, vectors use contiguous storage locations for their elements, which means that their elements can also be accessed using offsets on regular pointers to its elements, and just as efficiently as in arrays. But unlike arrays, their size can change dynamically, with their storage being handled automatically by the container.</blockquote>
</li>
	<li>Build to make sure it fails.</li>
</ol>
Now let's implement the class <em>LineToWordsClass</em> with method <em>splitLine</em>
<ol>
	<li>Add file LineToWordsClass.h in the <em>src</em> folder</li>
	<li>Add the following code:
<pre>
#ifndef LINETOWORDSCLASS_H_
#define LINETOWORDSCLASS_H_

#include &lt;string&gt;
#include &lt;vector&gt;

class LineToWordsClass {
public:
  std::vector&lt;std::string&gt; splitLine(std::string& textLine);
};

#endif /* LINETOWORDSCLASS_H_ */</pre>
</li>
	<li>Add file <em>LineToWordsClass.cpp</em> in the <em>src</em> folder</li>
	<li>Add the following code
<pre>
#include "LineToWordsClass.h"
#include &lt;sstream&gt;

std::vector<std::string> LineToWordsClass::splitLine(const std::string& textLine) {
  const int MAX_WORD_LENGTH { 20 };
  char tempbuff[50];

  resetInternalListOfWords();

  std::stringstream ss;

  //Copy string to stringstream
  ss << textLine;

  //Loop through stringstream looking for delimiter character
  while(ss.getline(tempbuff, MAX_WORD_LENGTH, wordDelimiter))
  {
    words.push_back(tempbuff);
  }

  return words;
}
</pre>
<li>Build and run the test.</li>
</ol>

TODO: Show implementation of resetInternalListOfWords()

<h3>Concatenate words into line of text</h3>
We have implemented two tests on the test list.
<ul>
	<li><span style="text-decoration: line-through;">retrieve the value of an argument switch</span></li>
	<li><span style="text-decoration: line-through;">split a line of text into words</span></li>
	<li>concatenate words into line of text</li>
	<li>replace all matching words with replacement word</li>
</ul>
Now we want to write a test to test drive how to concatenate words into a line of text. We create a new class <em>WordsToLineClass</em>.

We start with a test.

<ol>
<li>Add a new file <em>WordsToLineClassTest.cpp</em> in the <em>test</em> folder
<li>Add the following code:
<pre>
#include "gmock/gmock.h"
#include "WordsToLineClass.h"

class WordsToLineClassTest : public ::testing::Test {

};

TEST_F(WordsToLineClassTest, ConcatenateThreeWordsIntoLine)
{
  //Setup
  WordsToLineClass wordsToLineClass;

  std::vector&lt;std::string&gt; words;
  words.push_back("table");
  words.push_back("rocket");
  words.push_back("moon");

  std::string line;

  //Exercise
  line = wordsToLineClass.concatenateWords(words);

  //Verify
  ASSERT_EQ("table rocket moon", line);
}</pre>

The test verifies whether we can concatenate <em>table</em>, <em>rocket</em> and <em>moon</em> into the line:
<pre>
"table rocket moon"
</pre>
	<li>Build to make sure it fails.</li>
</ol>

Now we implement <em>WordsToLineClass</em> and method <em>concatenateWords</em>.

<ol>
  <li>Add new file <em>WordsToLineClass.h</em> in the <em>src</em> folder and add declaration of class <em>WordsToLineClass</em> with public method:
<pre>
std::string concatenateWords(std::vector&lt;std::string> words);
</pre>
 Remember to include &lt;string> and &lt;vector>.</li>
  <li>Implement the <em>concatenateWords</em> method in the corresponding .cpp class.</li>

<pre>
#include "WordsToLineClass.h"

std::string WordsToLineClass::concatenateWords(std::vector&lt;std::string> words)
{
  std::vector&lt;std::string>::iterator it;
  std::string line("");

  for(it = words.begin(); it != words.end(); it++)
  {
    line.append(*it);
    line.append(" ");
  }

  if(line.size() &gt; 0)
  {
    line.resize(line.size() - 1);
  }

  return line;
}
</pre>

We loop through all words and add them to the line. We also add a space as delimiter between words. We remove the space after the last word before returning.

<li>Build and run the test to make sure it passes:
<pre>
[----------] 1 test from WordsToLineClassTest
[ RUN      ] WordsToLineClassTest.ConcatenateThreeWordsIntoLine
[       OK ] WordsToLineClassTest.ConcatenateThreeWordsIntoLine (0 ms)
[----------] 1 test from WordsToLineClassTest (0 ms total)
</pre>

We are now free to refactor while under protection from the passing test case. One possible outcome can look like this.

WordsToLineClass.h
<pre>
#ifndef WORDSTOLINECLASS_H_
#define WORDSTOLINECLASS_H_

#include &lt;string>
#include &lt;vector>

class WordsToLineClass {
public:
  std::string concatenateWords(std::vector&lt;std::string> words);

private:
  std::string addWordToLine(std::string line, std::string word);
  std::string removeLastSpaceFromLine(std::string line);

};

#endif /* WORDSTOLINECLASS_H_ */
</pre>

WordsToLineClass.cpp
<pre>
#include "WordsToLineClass.h"

std::string WordsToLineClass::concatenateWords(std::vector&lt;std::string> words)
{
  std::vector&lt;std::string>::iterator it;
  std::string line("");

  for(it = words.begin(); it != words.end(); it++)
  {
    line = addWordToLine(line, *it);
  }

  line = removeLastSpaceFromLine(line);

  return line;
}

std::string WordsToLineClass::addWordToLine(std::string line, std::string word) {
  line.append(word);
  line.append(" ");
  return line;
}

std::string WordsToLineClass::removeLastSpaceFromLine(std::string line) {
  if(line.size() > 0)
  {
    line.resize(line.size() - 1);
  }

  return line;
}
</pre>

<h3>Replace all matching words with replacement word</h3>
We have implemented three tests on the test list.
<ul>
	<li><span style="text-decoration: line-through;">retrieve the value of an argument switch</span></li>
	<li><span style="text-decoration: line-through;">split a line of text into words</span></li>
	<li><span style="text-decoration: line-through;">concatenate words into line of text</span></li>
	<li>replace all matching words with replacement word</li>
</ul>

Now we want to test drive how to replace all words matching an <em>oldWord</em> with a <em>newWord</em>.

<ol>
<li>Edit <em>WordsrepClassTest.cpp</em> to look like this:

<pre>
#include "gmock/gmock.h"
#include "WordsrepClass.h"

class WordsrepClassTest : public ::testing::Test {

};

TEST_F(WordsrepClassTest, APassingTest) {
  ASSERT_TRUE(true);
}

TEST_F(WordsrepClassTest, ReplaceMatchingWordsWithNewWord)
{
  //Setup
  WordsrepClass wordsrepClass;

  std::vector&lt;std::string> words;
  words.push_back("table");
  words.push_back("rocket");
  words.push_back("moon");

  std::string oldWord("table");
  std::string newWord("sun");

  std::vector&lt;std::string> newWords;

  //Exercise
  newWords = wordsrepClass.replaceMatchingWords(oldWord, newWord, words);

  //Verify
  ASSERT_EQ("sun",    newWords[0]);
  ASSERT_EQ("rocket", newWords[1]);
  ASSERT_EQ("moon",   newWords[2]);
}</pre>

The test verifies that method <em>replaceMatchingWords</em> can find the <em>oldWord</em>, replace it with the <em>newWord</em> and the leave the other words as they are.

<li>Build to make sure it fails.</li>
</ol>


Now we implement method <em>replaceMatchingWords</em> in class <em>WordsrepClass</em>.

<ol>
	<li>Add file <em>WordsrepClass.h</em> in <em>src</em> folder with a declaration of <em>WordsrepClass</em> including public method:
<pre>
  std::vector&lt;std::string> replaceMatchingWords(
    std::string oldWord, std::string newWord,
    std::vector&lt;std::string> words);
</pre>
</li>
	<li>Implement the new method <em>replaceMatchingWords</em> in corresponding .cpp file.</li>

<pre>
#include "WordsrepClass.h"

std::vector&lt;std::string> WordsrepClass::replaceMatchingWords(
std::string oldWord, std::string newWord,
std::vector&lt;std::string> words) {

  std::vector&lt;std::string>::iterator it;
  std::vector&lt;std::string> newWords;

  for(it = words.begin(); it != words.end(); it++)
  {
    if((*it) == oldWord)
    {
      newWords.push_back(newWord);
    }
    else
    {
      newWords.push_back(*it);
    }
  }

  return newWords;
}
</pre>

<li>Build and run test to make sure it passes:
<pre>
[----------] 2 tests from WordsrepClassTest
[ RUN      ] WordsrepClassTest.APassingTest
[       OK ] WordsrepClassTest.APassingTest (0 ms)
[ RUN      ] WordsrepClassTest.
             ReplaceMatchingWordsWithNewWord
[       OK ] WordsrepClassTest.
             ReplaceMatchingWordsWithNewWord (0 ms)
[----------] 2 tests from WordsrepClassTest (0 ms total)
</pre>

<h3>Use mock objects to abstract the file system dependency</h3>
Ok, so we have implemented all the tests on our initial test list:
<ul>
	<li><span style="text-decoration: line-through;">retrieve the value of an argument switch</span></li>
	<li><span style="text-decoration: line-through;">split a line of text into words</span></li>
	<li><span style="text-decoration: line-through;">concatenate words into line of text</span></li>
	<li><span style="text-decoration: line-through;">replace all matching words with replacement word</span></li>
</ul>

But we are not done. <strong>WordsrepApp</strong> will have to read and write text lines from and to files. However this dependency towards a file system is typically something we want to abstract in our unit tests. We can do this using mock objects. What we have to do first is to define abstract interfaces through which WordsrepApp can interact with the file system. We will let mock objects implement the abstract interfaces while running our unit tests.

We define one abstract interface, <em>AbstractFileReaderInterface</em>, for reading from files. It stipulates that four methods should be implemented:

<ul>
<li>openFile
<li>closeFile
<li>readLine - returns next line
<li>endOfData - returns true if we have reached end of file
</ul>

We define one abstract interface, <em>AbstractFileWriterInterface</em>, for writing to files. It stipulates that four methods should be implemented:

<ul>
<li>openFile
<li>closeFile
<li>writeLine - inserts a string into the file but does not make a line feed
<li>lineFeed - inserts line feed into file
</ul>

The figure belows shows the abstract interfaces and how they can be implemented by mock ojects or the by the <em>real</em> classes.

<center><a href="http://localhost/wordpress/wp-content/uploads/300_MockObjects.png"><img class="alignnone size-medium wp-image-21" alt="300_MockObjects.png" src="http://localhost/wordpress/wp-content/uploads/300_MockObjects.png" /></a></center>

We use pure virtual methods to implement abstract classes. From Wikipedia:

<blockquote cite="http://en.wikipedia.org/wiki/Virtual_function#Abstract_classes_and_pure_virtual_functions">
A pure virtual function or <strong>pure virtual method</strong> is a virtual function that is required to be implemented by a derived class, if that class is not abstract. Classes containing pure virtual methods are termed "abstract" and they cannot be instantiated directly. A subclass of an abstract class can only be instantiated directly if all inherited pure virtual methods have been implemented by that class or a parent class. Pure virtual methods typically have a declaration (signature) and no definition (implementation).
</blockquote>

We add <strong>= 0</strong> to the method declaration (signature) to make it a pure virtual method.

Now we define the <em>AbstractFileReaderInterface</em> and <em>AbstractFileWriterInterface</em> in Eclipse.

<ul>
	<li>Add a new folder <em>interface</em> in the WordsrepApp project</li>
	<li>Add a new file <em>AbstractFileReaderInterface.h</em> in the <em>interface</em> folder</li>
	<li>Add the following code:
<pre>
#ifndef ABSTRACTFILEREADERINTERFACE_H_
#define ABSTRACTFILEREADERINTERFACE_H_

#include &lt;string> 

class AbstractFileReaderInterface {
public:
  virtual ~AbstractFileReaderInterface() {}
  virtual int openFile(std::string fileName) = 0;
  virtual int closeFile() = 0;
  virtual std::string readLine() = 0;
  virtual bool endOfData() = 0;
};

#endif /* ABSTRACTFILEREADERINTERFACE_H_ */</pre>
</li>
	<li>Add a new file <em>AbstractFileWriterInterface.h</em> in the <em>interface</em> folder</li>
	<li>Add the following code:
<pre>
#ifndef ABSTRACTFILEWRITERINTERFACE_H_
#define ABSTRACTFILEWRITERINTERFACE_H_

#include &lt;string&gt;

class AbstractFileWriterInterface {
public:
  virtual ~AbstractFileWriterInterface() {}
  virtual int openFile(std::string fileName) = 0;
  virtual int closeFile() = 0;
  virtual void writeLine(std::string newLine) = 0;
  virtual void lineFeed() = 0;
  virtual void setEndOfData() = 0;
};

#endif /* ABSTRACTFILEWRITERINTERFACE_H_ */

</pre>
</li>
</ul>

Next step is to create mock objects using Google Mock. We must tell Google Mock what abstract interface to implement. We do this by declaring a mock class that inherits from the abstract interface. We define the methods in the mock class using syntax:

<code>
MOCK_METHODn(<em>&lt;function name></em>, <em>&lt;type of function></em>);
</code>

n is the number of arguments. We write one MOCK_METHOD per pure virtual method in the abstract class. The examples below will make it more clear. You can also have a look at https://code.google.com/p/googlemock/wiki/V1_7_ForDummies#Writing_the_Mock_Class.

We start with the <em>FileReaderMock</em>.
<ul>
	<li>Add a new folder <em>mock</em> in the WordsrepApp project</li>
	<li>Add a new file <em>FileReaderMock.h</em></li>
	<li>Add the following code:
<pre>
#ifndef FILEREADERMOCK_H_
#define FILEREADERMOCK_H_

#include "gmock/gmock.h"
#include "AbstractFileReaderInterface.h"

class FileReaderMock : public AbstractFileReaderInterface {
public:
  MOCK_METHOD1(openFile, int(std::string fileName));
  MOCK_METHOD0(closeFile, int());
  MOCK_METHOD0(readLine, std::string());
  MOCK_METHOD0(endOfData, bool());
};

#endif /* FILEREADERMOCK_H_ */</pre>
</li>
</ul>

Now we create the <em>FileWriterMock</em>.
<ul>
	<li>Add a new file <em>FileWriterMock.h</em> in the <em>mock</em> folder.</li>
	<li>Add the following code:
<pre>
#ifndef FILEWRITERMOCK_H_
#define FILEWRITERMOCK_H_

#include "gmock/gmock.h"
#include "AbstractFileWriterInterface.h"

class FileWriterMock : public AbstractFileWriterInterface {
public:
  MOCK_METHOD1(openFile, int(std::string fileName));
  MOCK_METHOD0(closeFile, int());
  MOCK_METHOD1(writeLine, void(std::string newLine));
  MOCK_METHOD0(lineFeed, void());
  MOCK_METHOD0(setEndOfData, void());
};

#endif /* FILEWRITERMOCK_H_ */
</pre>
</li>
</ul>


We can now write a test which makes use of the mock objects to verify that the <em>WordsrepClass</em> interacts with the file interfaces correctly.

The sequence diagram below shows how we want the <em>WordsrepClass</em> to interact with the file interfaces.

<center><a href="http://localhost/wordpress/wp-content/uploads/400_WordsrepClassFileInterfaceInteractions.png"><img class="alignnone size-medium wp-image-21" alt="400_WordsrepClassFileInterfaceInteractions.png" src="http://localhost/wordpress/wp-content/uploads/400_WordsrepClassFileInterfaceInteractions.png" /></a></center>

We will now write the test <em>InteractsCorrectlyWithFileInterfaces</em> where we will:
<ol>
<li>Set expectations upon <em>FileReaderMock</em> and <em>FileWriterMock</em> according to the functions calls in the sequence diagram above
<li>Call method <em>processInputFile</em> belonging to <em>WordsrepClass</em>.

The mock objects will make the test fail if the function calls from <em>WordsrepClass</em> do not occur according to the expectations we have put on them.

We use the Google Mock macro EXPECT_CALL to set expectations upon the mock objects.
<code>
EXPECT_CALL(<em>&lt;mock object></em>, <em>&lt;method name including argument></em>)
.Times(<em>&lt;how many times we expect the method to be called></em>)
.WillOnce(<em>&lt;what the method in the mock should return></em>);
</code>

Example:

<code>
EXPECT_CALL(fileReaderMock, openFile("a.txt"))
.Times(Exactly(1))
.WillOnce(Return(0));
</code>

<ul>
	<li>Add the following includes to <em>WordsrepClassTest.cpp</em>
<pre>
#include "FileReaderMock.h"
#include "FileWriterMock.h"
</pre>
<li>Add the following lines after the includes in <em>WordsrepClassTest.cpp</em>:
<pre>
using ::testing::Exactly;
using ::testing::Return;
using ::testing::InSequence;
</pre>
</li>
	<li>Add the following test to <em>WordsrepClassTest.cpp</em>
<pre>
TEST_F(WordsrepClassTest, InteractsCorrectlyWithFileInterfaces)
{
  //Setup
  FileReaderMock fileReaderMock;
  FileWriterMock fileWriterMock;
  WordsrepClass wordsrepClass;

  //Set expectations on mock objects
  EXPECT_CALL(fileReaderMock, openFile("a.txt"))
  .Times(Exactly(1))
  .WillOnce(Return(0));

  EXPECT_CALL(fileWriterMock, openFile("b.txt"))
  .Times(Exactly(1))
  .WillOnce(Return(0));

  {
    InSequence s;

    EXPECT_CALL(fileReaderMock, endOfData())
    .Times(Exactly(1))
    .WillOnce(Return(false));

    //Line 1
    EXPECT_CALL(fileReaderMock, readLine())
    .Times(Exactly(1))
    .WillOnce(Return("car house street"));

    EXPECT_CALL(fileWriterMock, writeLine("house house street"))
    .Times(Exactly(1));

    EXPECT_CALL(fileReaderMock, endOfData())
    .Times(Exactly(1))
    .WillOnce(Return(false));

    //Line 2
    EXPECT_CALL(fileReaderMock, readLine())
    .Times(Exactly(1))
    .WillOnce(Return("space blue cow"));

    EXPECT_CALL(myFileWriterMock, lineFeed())
    .Times(Exactly(1));

    EXPECT_CALL(fileWriterMock, writeLine("space blue cow"))
    .Times(Exactly(1));

    EXPECT_CALL(fileReaderMock, endOfData())
    .Times(Exactly(1))
    .WillOnce(Return(true));
  }

  EXPECT_CALL(fileReaderMock, closeFile())
  .Times(Exactly(1))
  .WillOnce(Return(0));

  EXPECT_CALL(fileWriterMock, closeFile())
  .Times(Exactly(1))
  .WillOnce(Return(0));

  int argc = 9;
  const char * argv[] = {"wordsrep", "--oldWord", "car", "--newWord", "house", "--inputFile", "a.txt", "--outputFile", "b.txt"};

  //Exercise &amp; Verify
  wordsrepClass.processInputFile(argc, argv, &amp;fileReaderMock, &amp;fileWriterMock);
}
</pre>
</li>
</ul>

We must make the interfaces and mock objects available when building

<ul>
	<li>Edit Properties for the <em>mock</em> folder and add <em>interface</em> folder to the Include paths for GCC C++ Compiler</li>
	<li>Now edit Properties for the <em>test</em> folder and add <em>mock</em> and <em>interface</em> folders to Include paths</li>
</ul>
Build and run to make sure it fails. The build should fail because of missing member <em>processInputFile</em>.

Now we add the <em>processInputFile</em> method to the <em>WordsrepClass</em>.
<ul>
	<li>Add the following includes to <em>WordsrepClass.h</em>:
<pre>
#include "AbstractFileReaderInterface.h"
#include "AbstractFileWriterInterface.h"
</pre>
</li>
	<li>Now add the prototype for the new method:
<pre>
void processInputFile(int argc, const char* argv[], AbstractFileReaderInterface  * fileReader_p, AbstractFileWriterInterface * fileWriter_p);
</pre>
</li>
	<li>Add the folowing includes in <em>WordsrepClass.cpp</em>:
<pre>
#include "ArgumentParserClass.h"
#include "LineToWordsClass.h"
#include "WordsToLineClass.h"</pre>
</li>
	<li>The implementation of <em>processInputFile</em> looks like this:
<pre>
void WordsrepClass::processInputFile(int argc, const char* argv[],
AbstractFileReaderInterface* fileReader_p,
AbstractFileWriterInterface* fileWriter_p) {

  ArgumentParserClass argumentParserClass;
  WordsToLineClass wordsToLineClass;
  LineToWordsClass lineToWordsClass;

  std::string oldWord = argumentParserClass.getSwitchValue(argc, argv, "--oldWord");
  std::string newWord = argumentParserClass.getSwitchValue(argc, argv, "--newWord");
  std::string inputFile = argumentParserClass.getSwitchValue(argc, argv, "--inputFile");
  std::string outputFile = argumentParserClass.getSwitchValue(argc, argv, "--outputFile");

  fileReader_p-&gt;openFile(inputFile);
  fileWriter_p-&gt;openFile(outputFile);

  isFirstLine = true;
  while(false == fileReader_p-&gt;endOfData())
  {
    std::string tempLine = fileReader_p-&gt;readLine();

    std::vector&lt;std::string> words = lineToWordsClass.splitLine(tempLine);
    std::vector&lt;std::string> newWords = this-&gt;replaceMatchingWords(oldWord, newWord, words);
    tempLine = wordsToLineClass.concatenateWords(newWords);

    insertLineFeed(fileWriter_p);
    fileWriter_p-&gt;writeLine(tempLine);
  }

  fileWriter_p-&gt;closeFile();
  fileReader_p-&gt;closeFile();

}
</pre>
</li>
<li> We must also implement the helper method <em>insertLineFeed</em>. We add it to the class definition in <em>WordsrepClass.h</em> first:
<pre>
class WordsrepClass {
public:
  std::vector<lt;std::string>gt; replaceMatchingWords(
	std::string oldWord, std::string newWord,
	std::vector<lt;std::string>gt; words);
  void processInputFile(int argc, const char* argv[], AbstractFileReaderInterface  * fileReader_p, AbstractFileWriterInterface * fileWriter_p);

<strong>private:</strong>
  <strong>void insertLineFeed(AbstractFileWriterInterface* fileWriter_p);</strong>
  <strong>bool isFirstLine;</strong>

};
</pre>
</li>
<li>The method implementation in <em>WordsrepClass.cpp</em> looks like this:
<pre>
void WordsrepClass::insertLineFeed(AbstractFileWriterInterface* fileWriter_p) {
  if(!isFirstLine) {
    fileWriter_p-&gt;lineFeed();
  }
  isFirstLine  = false;
}
</pre>
</li>
	<li>Edit the properties of the <em>src</em> folder and add the <em>interface</em> folder to the Include paths</li>
	<li>Build and run to make sure the <em>InteractsCorrectlyWithFileInterfaces</em> test passes:
<pre>
[----------] 3 tests from WordsrepClassTest
[ RUN      ] WordsrepClassTest.APassingTest
[       OK ] WordsrepClassTest.APassingTest (0 ms)
[ RUN      ] WordsrepClassTest.
             ReplaceMatchingWordsWithNewWord
[       OK ] WordsrepClassTest.
             ReplaceMatchingWordsWithNewWord (0 ms)
[ RUN      ] WordsrepClassTest.
             InteractsCorrectlyWithFileInterfaces
[       OK ] WordsrepClassTest.
             InteractsCorrectlyWithFileInterfaces (1 ms)
[----------] 3 tests from WordsrepClassTest (1 ms total)
</pre>

</li>
</ul>

We want some of the function calls to occur in a specific sequence. We use the following Google Mock syntax in the test to achieve this:

<code>
{
    InSequence s;

    EXPECT_CALL(...
    EXPECT_CALL(...
    EXPECT_CALL(...
}
</code>

<h3>Implement the real file line reader and writer</h3>
Ok, we have implemented all our tests needed to test drive the basic functionality of the WordsrepApp. However we also want to test the actual command line tool. We must create a second main.cpp file to use when building the command line tool and not the unit tests. But we must start with implementing the FileReaderClass and FileWriterClass to interact with the actual file system.

We don't unit test this part of the code. But by moving all the <em>glue</em> code between the WordsrepApp core functionality and the actual file system we are allowed to test as much as possible of the code.
<ol>
	<li>Create a new file <em>FileReaderClass.h</em> in the <em>src</em> folder</li>
	<li>Add the following code:
<pre>
#ifndef FILEREADERCLASS_H_
#define FILEREADERCLASS_H_

#include "AbstractFileReaderInterface.h"
#include &lt;iostream>
#include &lt;fstream>

class FileReaderClass : public AbstractFileReaderInterface {
private:
std::ifstream myFile;

public:
  int openFile(std::string fileName);
  int closeFile();
  std::string readLine();
  bool endOfData();

};

#endif /* FILEREADERCLASS_H_ */
</pre>
</li>
	<li>Create a new file <em>FileReaderClass.cpp</em> in the <em>src</em> folder</li>
	<li>Add the following code:
<pre>
#include "FileReaderClass.h"

int FileReaderClass::openFile(std::string fileName) {
  const char * fileNameChar_p = fileName.c_str();
  this-&gt;myFile.open(fileNameChar_p, std::fstream::in);
  return 0;
}

std::string FileReaderClass::readLine() {
  const int MAXLENGTH = 500;
  char rad[MAXLENGTH+1];
  this-&gt;myFile.getline(rad, MAXLENGTH);
  return std::string(rad);
}

bool FileReaderClass::endOfData() {
  return this-&gt;myFile.eof();
}

int FileReaderClass::closeFile()
{
  this-&gt;myFile.close();
  return 0;
}
</pre>
</li>
	<li>Create a new file <em>FileWriterClass.h</em> in the <em>src</em> folder</li>
	<li>Add the following code:
<pre>
#ifndef FILEWRITERCLASS_H_
#define FILEWRITERCLASS_H_

#include "AbstractFileWriterInterface.h"
#include &lt;iostream>
#include &lt;fstream>

class FileWriterClass : public AbstractFileWriterInterface {
private:
  std::ofstream myFile;

public:
  int openFile(std::string fileName);
  int closeFile();
  void writeLine(std::string line);
  void lineFeed();
  void setEndOfData();

};

#endif /* FILEWRITERCLASS_H_ */
</pre>
</li>
	<li>Create a new file <em>FileWriterClass.cpp</em> in the <em>src</em> folder</li>
	<li>Add the following code:
<pre>
#include "FileWriterClass.h"

int FileWriterClass::openFile(std::string fileName) {
  const char * fileNameChar_p = fileName.c_str();
  this-&gt;myFile.open(fileNameChar_p);
  return 0;
}

int FileWriterClass::closeFile() {
  this-&gt;myFile.close();
  return 0;
}

void FileWriterClass::writeLine(std::string line) {
  this-&gt;myFile &lt;&lt; line;
}

void FileWriterClass::lineFeed() {
  this-&gt;myFile &lt;&lt; '\n';
}


void FileWriterClass::setEndOfData() {
  this-&gt;closeFile();
}
</pre>
</li>
</ol>
<h3>Compile command line application</h3>
We must add a new <em>main.cpp</em> to run the <em>WordsrepApp</em> from the command line. We must also configure the Eclipse project to build either with the <em>main.cpp</em> used with Google Tests or the <em>main.cpp</em> to use for the actual command line application.
<ol>
	<li>Add a new file <em>main.cpp</em> in the <em>src</em> folder</li>
	<li>Add the following code
<pre>
#include "WordsrepClass.h"
#include "FileReaderClass.h"
#include "FileWriterClass.h"

int main(int argc, const char * argv[])
{
  FileReaderClass fileReaderClass;
  FileWriterClass fileWriterClass;
  WordsrepClass wordsrepClass;

  wordsrepClass.processInputFile(argc, argv, &amp;fileReaderClass, &amp;fileWriterClass);

  return 0;
}
</pre>
</li>
	<li>Right click on the new <em>main.cpp</em> file and select Propterties</li>
	<li>Click on C/C++ Build</li>
	<li>Make sure Configuration is set to <em>Debug</em></li>
	<li>Set box <em>Exclude resource from build</em></li>
	<li>Click OK</li>
</ol>
We have created the new <em>main.cpp</em> file but excluded it from build when we are running Google Tests. You can try this by ensuring that you can still build the project and run the tests.

Now we switch to the release build configuration and build the command line tool.
<ol>
	<li>Select Project - Build Configurations - Set Active - Release</li>
	<li>Right-click on the <em>test</em> folder and activate <em>Exclude resource from build</em> under C/C++ Build</li>
	<li>Click OK</li>
	<li>Right-click on the <em>mock</em> folder and activate <em>Exclude resource from build</em> under C/C++ Build</li>
	<li>Click OK</li>
	<li>Right-click on the <em>external</em> folder and activate <em>Exclude resource from build</em> under C/C++ Build</li>
	<li>Click OK</li>
	<li>Edit Properties of the <em>src</em> folder and add the <em>interface</em> folder to the Include paths</li>
	<li>Build the project</li>
</ol>
Now we want test our command line utlity!
<ol>
	<li>Click on Start menu - Accessories - LXTerminal</li>
	<li>Change folder to your WordsrepApp git repository
<pre>
cd /home/tdd1/git/WordsrepAppGit/WordsrepApp/
</pre>
</li>
	<li>Go into the <em>Release</em> folder
<pre>
cd Release
</pre>
</li>
	<li>You should have the <em>WordsrepApp</em> binary in the <em>Release</em> folder</li>
	<li>Create a text file <em>a.txt</em> containing the following lines:
<pre>
house car space
cycle table chair
</pre>
</li>
	<li>Execute the WordsrepApp:
<pre>
./WordsrepApp --oldWord car --newWord black --inputFile a.txt --outputFile b.txt</pre>
</li>
	<li>Check the output by executing:
<pre>cat b.txt</pre>
</li>
	<li>You should get:
<pre>
house black space
cycle table chair
</pre>
</li>
</ol>
<h3>Connect Google Tests to a Continuous Integration Server</h3>
Finally we will connect our tests to a continuous integration server, in this case Jenkins.

There is a reference project, <a href="http://localhost/jenkins/job/WordsrepAppReferenceTests/" title="WordsrepAppReferenceTests" target="_blank">WordsrepAppReferenceTests</a>, setup in Jenkins which you can look at it if you run into problems when performing the steps below.

<ol>
	<li>Make sure you have commited all your files to git</li>
	<li>Go to <code>localhost/jenkins</code> in the webbrowser</li>
	<li>Click on New Job</li>
	<li>Enter job name <code>WordsrepAppTests</code><center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Screenshot_jenkins_job_name.png" /></center></li>
	<li>Select <em>Build a free-style software project</em> and click OK</li>
	<li>Select <em>Git</em> in section <em>Source Code Management</em></li>
	<li>Enter <em>Repository URL</em>:
<pre>
/home/tdd1/git/WordsrepAppGit/.git
</pre>
</li>
	<li>Click on <em>Add build step</em> in section <em>Build</em> and select <em>Execute shell</em></li>
	<li>Paste the following in the Command box:
<pre>
eclipse -nosplash -application org.eclipse.cdt.managedbuilder.core.headlessbuild -data . -import WordsrepApp -cleanBuild WordsrepApp/Debug
./WordsrepApp/Debug/WordsrepApp --gtest_output="xml:WordsRepApp_TestResults.xml"
</pre>
</li>
	<li>Click on <em>Add post-build action</em> in section <em>Post-build Actions</em> and select <em>Publish JUnit test result report</em></li>
	<li>Enter the following in box <em>Test report XMLs</em>: 
<pre>
WordsRepApp_TestResults.xml
</pre>
</li>
        <li>Click on Apply
	<li>Click on Save</li>
	<li>Click on <em>Build now</em>
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Screenshot_jenkins_build_now.png" /></center></li>
	<li>The build history should show the first job as blue after some time, indicating that the build went fine and all tests passed:
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Screenshot_jenkins_build_history.png" /></center></li>
	<li>Click on the job in the Build History</li>
	<li>Click on <em>Test result</em></li>
	<li>Click on <em>(root)</em></li>
	<li>You should now get a list of all test classes with corresponding test results
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Screenshot_jenkins_test_classes.png" /></center></li>
	<li>Click on <em>WordsrepClassTest</em> to get the results of each test in that test class
<center><img alt="" src="http://localhost/wordpress/wp-content/uploads/Screenshot_jenkins_test_results.png" /></center></li>
</ol>
The Jenkins job we have created is now setup to run when manually triggered. It is also possible to setup the job to be triggered automatically.

<h3>Test drive dynamic word delimiter</h3>

You have fulfilled all the original requirements on the <strong>wordsrep</strong> application. However now we have a new requirement coming in. The customers want to specify what delimiter to use between words. The delimiter can no longer be hardcoded to space. It should now be possible to run wordsrep with the new argument <em>--wordDelimiter</em>.

[table id=4 /]

<strong>Example</strong>
To set the delimiter to # we run wordsrep like this:
<pre>wordsrep --oldWord car --newWord house --inputFile a.txt --outputFile b.txt --wordDelimiter \#</pre>
The backslash is needed to tell the Bash to not interpret # as the start of a comment.

a.txt
<pre>
car#horse#tree
</pre>

b.txt
<pre>
house#horse#tree
</pre>

You must implement the following tests to add support for setting the wordDelimiter:
[table id=5 /]

<strong>LineToWordsClass</strong>

The <em>LineToWordsClass</em> must implement a new method <code>setWordDelimiter</code>. It should be possible to set a word delimiter of one character using the new method. The new test <em>CanSplitLineUsingDynamicWordDelimiter</em> shall verify that a new delimiter can be set and also used to split up a line into words.

<strong>WordsToLineClass</strong>

The <em>WordsToLineClass</em> must also implement a new method <code>setWordDelimiter</code> with similar purpose as in <em>LineToWordsClass</em>. The new test <em>ConcatenateWordsUsingDynamicWordDelimiter</em> shall verify that a new delimiter can be set and also used to concatenate words into a line.

<strong>WordsrepClass</strong>

The <em>processInputFile</em> method in <em>WordsrepClass</em> must now check whether the <em>wordDelimiter</em> argument has been specified at the command line. It must then pass the new word delimiter onto the other classes via the <code>setWordDelimiter</code> methods. The new test <em>CanUseNonSpaceWordDelimiter</em> shall verify that we can now make use of the new argument <em>wordDelimiter</em>.

Remember that you can check the reference project if you get stuck while test driving the new functionality:
<pre>/home/tdd1/workspace_reference</pre>
The <em>WordsrepClassTest</em> has been cleaned up in the reference project and makes use of the fixture class to avoid duplication when settting mock expectations.

<h3>About this course</h3>

This course was created with <em>passion</em> and some degree of <em>innovation</em>. I now <em>trust</em> you to give me feedback so that it can be continuously improved. ;)

jacob.mossberg@cybercom.com
twitter.com/jcmossberg

<a href="http://localhost/wordpress/wp-content/uploads/jacobmossberg.jpg"><img class="alignnone size-medium wp-image-21" src="http://localhost/wordpress/wp-content/uploads/jacobmossberg.jpg" width="150" /></a>
